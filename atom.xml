<?xml version="1.0" encoding="UTF-8" ?>
  <feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ground Oddity</title>
  <subtitle>Personal blog of Jiahao Cai</subtitle>
  <link href="http://jujuba.me/"/>
  <link href="http://jujuba.me/atom.xml" rel="self" type="application/atom+xml"/>
  <author>
    <name>Jiahao Cai</name>
  </author>
  <id>http://jujuba.me/</id>
<updated>2020-03-06T11:29:02.309197-05:00</updated>
<entry><title>我在欧洲的几次旅行</title><published>Jul 2, 2018</published><updated>2020-03-06T11:20:44Z</updated><link href="http://jujuba.me/posts/travel-in-europe.html"/><id>http://jujuba.me/posts/travel-in-europe.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">我在欧洲的几次旅行</h1>
<p class="date">Jul 2, 2018</p>
</header>
<p><img alt="travel in europe" src="../imgs/travel-in-europe.jpeg" style="height: 350px;"/></p>
<h2 id="巴黎">1. 巴黎</h2>
<p>巴黎给我的印象就是很美，宁静又喧嚣的，古朴的美。除此之外，还感觉巴黎的地铁太过复杂，就好像一段写满了temporary hacking的代码，再就是巴黎的很多地方都可以看到中文，以及法国人真的很不喜欢用英语，每次去饭店点个菜都发现菜单是全法语的，点菜困难。我去了几个著名的地方打了卡，巴黎圣母院，卢浮宫，埃菲尔铁塔，等等。</p>
<p><img alt="paris" src="../imgs/paris-0.jpeg" style="height: 300px;"/> <img alt="paris" src="../imgs/paris-1.jpeg" style="height: 300px;"/> <img alt="paris" src="../imgs/paris-2.jpeg" style="height: 300px;"/> <img alt="paris" src="../imgs/paris-3.jpeg" style="height: 300px;"/></p>
<p>走的那天在地铁上碰到一个法国女生，聊了一会发现她会好几句中文，真是厉害。她对我只在巴黎呆两天且没吃马卡龙的行为表示强烈抗议，我想了下，出门之前貌似是没怎么做功课，一般就随便走进一家看得顺眼的饭店就吃了，万幸的是貌似都挺好吃的。</p>
<p>当天晚上我离开巴黎前往布鲁塞尔，离开之前刚吃了一大块liver撑得要死，结果一上火车，乘务员又开始准备吃的了。这时候我才发现为什么这张巴黎到布鲁塞尔的车票这么贵，要50欧+，虽然很撑，我还是把火车上的食物都吃完了，因为真的很好吃。</p>
<h2 id="布鲁塞尔">2. 布鲁塞尔</h2>
<p>布鲁塞尔是个很小很精致的城市，就像比利时的其他城市一样，我并不是非常喜欢，因为建筑物之间的距离太近了，显得有些压抑。我刚到比利时的时候，就在公车上碰到一个五六十岁的老奶奶和她的孙子，她说她去过中国，包括北京，台湾。我们聊了一会乱七八糟的事，她告诉我在布鲁塞尔一定要注意安全，特别是在这样的深夜里（我总是深夜里到达一个城市…），她说“I am not trying to scare you, but they can be very violent”，她还跟我说坐在车上不要把自己的包放下来，我看了下她，发现她真的上了车还背着包的。</p>
<p>布鲁塞尔吃的东西还不错，包括薯条，海鲜，巧克力以及华夫饼。</p>
<p><img alt="brussel waffle" src="../imgs/brussel-waffle.jpeg" style="height: 300px;"/> <img alt="brussel seafood" src="../imgs/brussel-seafood-0.jpeg" style="height: 300px;"/> <img alt="brussel seafood" src="../imgs/brussel-seafood-1.jpeg" style="height: 300px;"/></p>
<p>晚上在布鲁塞尔去阿姆斯特丹的火车上，对面坐了一个学business的比利时人，David，他说他打算做一个可以追踪各种演唱会音乐会信息的App。我问他怎么做冷启动，他说他已经拉到了很多酒吧的投资，到时候可以通过酒吧来推销他的App。说着他就打开了他的ppt给我看，然后我突然发现他就是鲁汶大学的大四学生，作为一个刚被鲁汶拒了没几天的人，我感到有点尴尬，我们就顺便聊了一会关于鲁汶大学的事。他跟我说，他缺个程序员，问我写过App没，我说我就写过个Android App，他就想叫我跟他一起创业，说他现在有几万欧的启动资金，想让我去当主程。我很怂地说我需要先完成我的Master Degree，他的反应大概就是，come on…</p>
<p>我发现我遇到的好多外国人对中国的了解确实挺少的，我跟David聊了很多中国的东西，比如中国的现状，文革，计划生育，GFW，我们如何在Big Brother的Watching之下无所遁形之类的，他就一直说This is crazy。其实我觉得很多事何止crazy，简直就是creepy了。</p>
<p>他也给我介绍了一个有趣的活动，叫做<a href="https://en.wikipedia.org/wiki/Urban_exploration">urbex</a>，全名应该叫Urban exploration，主要目的是探索各种人造建筑，比如下水道，地下墓穴，隧道等。David说比利时有很多废弃的城堡，他最喜欢和他女朋友一起去探索那些城堡了，他说他是带着respect去探索的，并不会去改变城堡原有的样子。当然有时候这种exploration也会带来危险，比如他说他会在废弃城堡里见到吸毒的人，他们毫无respect，经常会破坏城堡，也有可能在毒品的作用下发狂从而伤害别人；比如说他也会去探索废弃的化工厂，但是去之前需要做很多的功课，去的时候一定要戴上防毒面具，不然的话很容易中毒。</p>
<p>我们也分享了很多我们喜欢看的剧，比如South Park。他还喜欢看Rick and Morty，海贼王，King of the hill之类的，甚至还掏出一件写着中文的“一家之主”的套头衫给我看。听了他的推荐，现在不知不觉我也看King of the hill看到第九季了 :)</p>
<p>David貌似是去海牙看他的女朋友，而我则要一直坐到阿姆斯特丹。</p>
<h2 id="阿姆斯特丹">3. 阿姆斯特丹</h2>
<p>阿姆斯特丹真的很自由很美好。我到达阿姆斯特丹的时候是晚上11点，一推开Hostel的门就看到5个法国人在喝酒抽大麻，最大的92年生的，最小的97年。他们看到我很开心，请我一起喝伏特加和另一种酒，当然还有请我抽大麻。我们分享了很多事，主要是音乐上的，他们给我推荐了好多法国的本地歌手（尽管我都不认识），我们一起讨论共同喜欢的摇滚乐队，Pink Floyd, Halestorm, Guns N’ Roses, AC/DC之类。当然我们还都很喜欢Star Wars，那段时间正好是The Last Jedi上映的时候，其中有个法国人打扮得就很Jedi，他戴上帽子就很像一个真正的Jedi。后来我又被拉去了酒吧，准确地说是<a href="https://en.wikipedia.org/wiki/Coffeeshop_(Netherlands)">Coffee Shop</a>，就是合法卖大麻的地方。那是晚上12点，阿姆斯特丹的Coffee Shop异常拥挤，我们在一家外面等了20分钟，放弃，然后在另一家门口等了10分钟，终于让我们进去了。我们在里面一起喝啤酒也喝龙舌兰，我第一次学到喝龙舌兰的正确姿势，原来需要配上盐和柠檬。Coffee Shop里挤满了人，当听到有人在唱Sweet Child O’ Mine的时候，我们都沸腾了，果然音乐是没有国界的，那真的是一个让我，即使现在回想起来依然万分感动的瞬间。喝多了之后，并不知道是大麻还是酒精的作用，我觉得我开始漂浮，朦朦胧胧中听到有个法国人跟我说他喜欢男人，我表示非常理解，我也确实觉得男人和男人呆在一起是很有趣的一件事。半夜三点多，我觉得我快醉了，就打算离开，我跟每个人拥抱说再见，然后我就走回了Hostel，一路上我看到阿姆斯特丹依然充满活力充满生机，大批的人依然在活跃在这个城市的夜里，这让我感觉非常美好。</p>
<p>第二天早上起来，大家都没醒，但是我得起来准备退房了，逛一逛阿姆斯特丹（阿姆斯特丹有很多很可爱的博物馆），然后晚上又要准备奔赴德国汉堡了。我想了想，写了张纸条向我的法国朋友们告别，我知道他们一定能看到这张纸条，因为我把这张纸条压在了那瓶没喝完的伏特加的下面 :D</p>
<figure>
<img alt="farewell" src="../imgs/bye-french.jpeg" style="height: 300px;"/>
<figcaption>
请原谅我糟糕的handwriting
</figcaption>
</figure>
<h2 id="汉堡">4. 汉堡</h2>
<p>我在汉堡住了两三天，不过大部分时间都又回到荷兰的恩斯赫德去了，因为那时候我刚被University of Twente录取，想过去看一下，而这个学校正好在荷兰与德国的边境上。我对汉堡的印象并不是很深，就记得我去的时候基本都是阴天下雨，不过德国的啤酒和食物深得我心。记得比较清楚的一件事是，我在汉堡闯红灯，侧面有辆车开过来，完全没有减速的意思，我只好很快速而又狼狈地跑到对面。这与荷兰瑞典就大不相同，荷兰瑞典的司机一定不会这么干。有好多次，我一个人站着等红灯，司机直接就停下来让我先走了，我第一次碰到这个情况的时候简直一脸懵逼。感觉这是不是跟传说中的“德国人特别遵守规则”有关系，鉴于我遇到的例子太少，也许这只是我的脑子里的stereotype吧。</p>
<p>后来看了一部德国电影，<a href="https://en.wikipedia.org/wiki/The_Lives_of_Others">The lives of others</a>（中文名愚蠢地翻译为窃听风暴），又对德国有了新的认识。</p>
<p>值得一提的是，汉堡到哥本哈根的火车很有趣，是一截很短的火车，开着开着就开到船肚子里去了，然后我们就下车到船上，该吃饭的吃饭，休息的休息，等船开到对岸了，我们再回到火车上，直到开到终点。</p>
<center>
<img alt="hamburger to copenhagen" src="../imgs/hamburger-denmark-0.jpeg" style="height: 400px;"/> <img alt="hamburger to copenhagen" src="../imgs/hamburger-denmark-1.jpeg" style="height: 400px;"/>
</center>
<h2 id="卑尔根-奥斯陆">5. 卑尔根 &amp; 奥斯陆</h2>
<p>挪威从一开始就惊艳到我了，从飞机上往下看，可以看到白雪皑皑的峡湾，就像大地起伏的皱纹，那个时候，真的会感觉心灵很宁静，而且在心中升起一股对自然的敬畏。</p>
<center>
<img alt="fjord in Norway" src="../imgs/fjord.jpeg" style="height: 400px;"/>
</center>
<p>卑尔根是个很美丽很美丽的城市，美中不足的是卑尔根每年下雨的日子往往接近300天，有“欧洲西雅图”之称，而人们无法在雨天领略卑尔根全部的美。</p>
<center>
<img alt="view in Bergen" src="../imgs/bergen-in-rain-1.jpeg" style="height: 400px;"/> <img alt="view in Bergen" src="../imgs/bergen-in-rain-2.jpeg" style="height: 400px;"/> <img alt="view in Bergen" src="../imgs/bergen-in-rain-3.jpeg" style="height: 400px;"/>
</center>
<p>刚到卑尔根的时候，我准备去一家当地比较著名的餐厅吃午饭，到了之后发现那里已经没有座位了，于是就跟一个印度朋友，Pankaj，坐在一起聊了起来。Pankaj说他是来哥本哈根参加一个Docker的conference，结束之后顺便来挪威玩的，他说他在印度某high frequency trading工作，我一听他是搞IT的，就开始跟他聊了一些业界的事。他来挪威是参加了一个叫做<a href="https://www.norwaynutshell.com/">Norway in a nutshell</a>的项目，这个项目很棒，会带他去看挪威最美的峡湾，去划独木舟，去探险去泡温泉等等。他说他其实还有个朋友跟他一起来开会的，可是他朋友是个素食主义者，所以就不愿意和他一起来吃饭，他朋友去海洋公园看动物去了 :D 那天下雨，整个卑尔根都雾蒙蒙的，我和Pankaj在城里漫无目的地闲逛。卑尔根真的是个小城，就这样随便走走，我们已经逛完了大部分的卑尔根，包括鱼市，卑尔根古城，布吕根码头以及各个教堂。虽然是小雨，但是在小雨下淋几个小时也不是什么轻松的事，后来我们选择去喝咖啡暖一下，喝着喝着，Pankaj的朋友也过来了，这好像是我第一次跟一个素食主义者相处。他并没有显得跟我们有什么不一样，喝完咖啡之后，我和Pankaj在他面前若无其事地啃着鹿肉香肠，他也并没有什么反应，甚至还走到M记里买了一个素食汉堡。傍晚我们在某个广场分别，Pankaj和他的朋友第二天要去斯塔万格（Stavanger），而我则要留在卑尔根，希望他们一切都好。</p>
<p>我很幸运，第二天卑尔根的天气是个大晴天，晴天的卑尔根真的很美，我一个人在漫无目的地走着，走累了就随便坐一会，有时候在观察这里的人是如何生活的，有时候在观察远方清澈的群山，有时候只是单纯地看鸟，喂鸟。</p>
<center>
<img alt="view in Bergen" src="../imgs/bergen-1.jpeg" style="height: 400px;"/> <img alt="view in Bergen" src="../imgs/bergen-2.jpeg" style="height: 400px;"/> <img alt="view in Bergen" src="../imgs/bergen-3.jpeg" style="height: 400px;"/>
</center>
<p>去卑尔根不得不去的就是弗洛伊恩山，风景很美，并不是很高，大约40分钟可以到山顶，也可以选择坐索道上下山。在山顶可以俯瞰整个卑尔根，还可以看到北大西洋上的船缓缓开过。</p>
<p><img alt="Fløyen, Bergen, Norway" src="../imgs/bergen-floyen.jpeg" style="height: 400px;"/></p>
<p>晚上11点我要坐夜车去奥斯陆，快要夏天了，北欧的白天已经变得很长很长了，一直到晚上11点，天也没有完全黑，我一直静静地坐在湖边，享受这挪威的阳光。后来我有点后悔坐了夜车去奥斯陆，因为我突然发现，在挪威，沿途的风光是如此不同，我应该白天坐火车的，这样我就可以欣赏更多挪威的风景了。</p>
<p>到了奥斯陆之后，才发现为什么说卑尔根的人都会自称来自卑尔根而不是挪威 XD 因为跟卑尔根比起来，奥斯陆真的逊了好多筹。个人主观感觉就是奥斯陆好土，而且几乎每走500m就会看到一个乞讨的难民，让人感觉有些不自在。我对奥斯陆仅有的回忆就是，我在奥斯陆拍了一张魔幻的照片，我总觉得这是人类败给AI之后的，荒芜的世界，让我感到很压抑。</p>
<center>
<img alt="Oslo, Norway" src="../imgs/oslo.jpeg" style="height: 500px;"/>
</center>
<p>就好像是The Matrix里的世界，让我有种驾驶着Nebuchadnezzar冲破这些乌云直到看见太阳的冲动。</p>
<center>
<img alt="Nebuchadnezzar above the black sky" src="../imgs/nebuchadnezzar-above-the-black-sky.png" style="height: 400px;"/>
</center>
<p>值得一提的是挪威的食物，大部分时间我都在吃M记的汉堡，一方面是因为挪威的食物太贵了，另一方面是因为挪威的食物有些真的欣赏不了，不过在卑尔根吃的鱼汉堡还是很让我怀念的。</p>
<h2 id="罗马">6. 罗马</h2>
<p>罗马是我去过最喜欢的城市，没有之一。雄伟壮观的万神殿与斗兽场自不必说，更让我沉醉的是罗马的艺术氛围，古老的教堂和随处可见的街头艺人。其厚重的历史无处不在，比如说罗马居然没有地铁，为什么呢，因为每次一开挖的时候就会挖到各种各样的遗址，导致施工无法继续进行。罗马的食物也很诱人，披萨，冰淇淋，提拉米苏…</p>
<center>
<img alt="Roma, Italy" src="../imgs/roma-1.jpeg" style="height: 300px;"/> <img alt="Roma, Italy" src="../imgs/roma-2.jpeg" style="height: 300px;"/> <img alt="Roma, Italy" src="../imgs/roma-3.jpeg" style="height: 300px;"/> <img alt="Roma, Italy" src="../imgs/roma-4.jpeg" style="height: 300px;"/>
</center>
<p>去罗马的时候我选择了Airbnb而不是像以前一样住在hostel里，因为像我这样不太主动开口说话的人，住在hostel里也很少遇到会一起说很多话的人，而房东则不一样，至少我可以跟本地人交流一些话题。我的房东，Alberto，是一个罗马人，还是本科生，在罗马大学读生物，他和他哥哥Dario住在一起，Dario是罗马大学的物理phd，看到他们两个之后，这是我这辈子第一次觉得，有兄弟姐妹真的是一件好事，sigh。我们一起谈论了很多有意思的事：</p>
<ul>
<li><p>第一天晚上我与Alberto站着聊天，他说他从来没有跟中国人聊过天，他对中国人的所有了解都来自于附近的中国商店，他只觉得中国人似乎很沉默，然后working crazy，然后我就试着解释了一下这些现象。不过这并不是重点，重点是我们聊天的时候有一只蚊子飞来飞去，我们都在骂damn mosquito，然后开始抓蚊子，Alberto成功把蚊子抓在了手里。当他发现这只蚊子还活着的时候，他说 “Let’s save this life”，然后就一路小跑打开窗户把蚊子给放了出去。说实话，这是对我冲击挺大的一件事，从前我一直以为这种事只会出现在艺术作品里，我真的从来从来没有想过要这么做，直到今天我还经常想起这件事，想起Alberto的举动。</p></li>
<li><p>第二天晚上Alberto和Dario都在，我们聊了一会关于中国的事，依然是关于现状，关于计划生育，关于GFW，关于我们的隐私。特别搞笑的是Alberto去上厕所了，我跟Dario就开始瞎扯，他说自己是物理phd，我马上就说那你一定知道Richard Feynman吧，他很惊讶地问我怎么知道Feynman的，他说“not a lot of people know Feynman”，我说是某个教我的professor告诉我的。我们聊了很多关于Feynman的事，包括他如何不屑于诺贝尔奖，包括费曼讲义如何使Dario获益。后来Dario刚说完“You know Feynman says physics is like sex…”，Alberto刚好走过来说“Are you talking about sex? Ah, woman, it’s always about woman”，于是我跟Dario相视一笑。</p></li>
<li><p>Dario说他花了2000欧买了一辆1979年的房车，现在已经修好并且可以开了，他打算phd毕业之后开着这辆房车一直从罗马开到北极圈，然后再换一条路线开回来，他算了一下，一路上都住在他认识的人家里的话，单程大概就要开5000公里。他说他一定要去，就算到时候只有他一个人也要去，走之前我特意加了他的facebook，我对他说，你要出发的时候一定要告诉我 :)</p></li>
<li><p>在罗马有一个Trevi Fountain，中文世界里有叫它<a href="https://place.qyer.com/poi/V2EJalFiBzVTZg/">许愿池</a>的。我一开始还以为是投硬币就可以许一个愿望的，但是Dario告诉我并不是这样的，他说如果你在Trevi Fountain里投下一枚硬币，那就说明你这辈子会再次回到罗马。我投下了一枚硬币，并且坚信我会再回到罗马。</p></li>
</ul>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>如何在终端中优雅地听歌</title><published>Apr 10, 2018</published><updated>2020-03-06T11:20:44Z</updated><link href="http://jujuba.me/posts/terminal_music.html"/><id>http://jujuba.me/posts/terminal_music.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">如何在终端中优雅地听歌</h1>
<p class="date">Apr 10, 2018</p>
</header>
<p><img alt="play_music_in_terminal" src="../imgs/terminal_music.png" style="height: 350px;"/></p>
<h2 id="起因">0. 起因</h2>
<p>起因就是对探索新歌失去了兴趣，并且觉得各种音乐播放软件都不怎么好用，而且懒癌发作，觉得写代码的时候想要换歌还要切换到音乐播放器再切回来实在太烦了。于是我把自己喜欢听的歌都下载下来了，放到一个文件夹里，准备用终端播放。整个过程非常简单，我所需要的只是一个想法和几行代码，迭代几次就搞定了。</p>
<h2 id="几次迭代">1. 几次迭代</h2>
<p>查了一下网上所谓的终端音乐播放器，似乎都不怎么样，有些还写了巨丑无比的UI，在命令行里画UI是个需要taste的事，画不好就会很丑，显然我不需要这些东西。找着找着，发现macOS上本来就有个命令行播放器，叫afplay，用法也很简单afplay后面加文件名就OK了，我想了想就用它了吧。</p>
<p>一开始想要的功能很简单，我需要方便地随机播放文件夹下的所有歌曲。我想了想，在<code>.zshrc</code>里写下了如下代码：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="va">BYel=</span><span class="st">'\e[0;33m'</span>;</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">function</span><span class="fu"> m()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="va">m_path=</span>~/Music/</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="va">song_num=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ls</span> <span class="va">$m_path</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="va">)</span><span class="st">"</span>                 <span class="co"># Total number of songs</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="va">timestamp=$(</span><span class="fu">date</span> +%s<span class="va">)</span>                       <span class="co"># Timestamp as millsecond, e.g. 1523305473</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="va">song_index=$(($timestamp</span>%<span class="va">$song_num</span>+1<span class="va">))</span>      <span class="co"># Generate a random song index</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="va">song=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ls</span> <span class="va">$m_path</span> <span class="kw">|</span> <span class="fu">sed</span> -n <span class="st">"</span><span class="va">$song_index</span><span class="st">"</span>p<span class="va">)</span><span class="st">"</span>     <span class="co"># Get the name of the certain song</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="bu">echo</span> -e <span class="st">"</span><span class="va">${BYel}$song</span><span class="st">"</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="ex">afplay</span> <span class="st">"</span><span class="va">$m_path$song</span><span class="st">"</span>                            <span class="co"># Play it!</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">}</span></a></code></pre></div>
<p>这样的话，每次我在终端里输入<code>m</code>，就可以随机播放一首歌曲。但是此时我面临了四个问题：</p>
<ol type="1">
<li>我不希望我为了这个“播放器”单独开一个终端，每次我要切歌，我还得先切到那个终端，</li>
<li>当我连续切歌时，随机性很差，因为文件是按文件名排序的，连续切歌时，时间戳增长不多，往往放来放去都是同一个人的歌，</li>
<li>目前的播放器实在太佛系了，只能随机放歌，其实有时候我也会想定向检索一首歌的，</li>
<li>每首歌放完之后都要重新输入m才可以开始下一首，是否可以自动播放下一首。</li>
</ol>
<p>下面一个个解决这些问题：</p>
<blockquote>
<ol type="1">
<li>我不希望我为了这个“播放器”单独开一个终端，每次我要切歌，我还得先切到那个终端</li>
</ol>
</blockquote>
<p>很简单，将afplay的进程改为后台即可，具体做法是加上一个&amp;号，然后你就可以接着在这个终端里干活了。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span><span class="fu"> m()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="ex">...</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="ex">afplay</span> <span class="st">"</span><span class="va">$m_path$song</span><span class="st">"</span> <span class="kw">&amp;</span>                          <span class="co"># &amp; will make the process running background</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">}</span></a></code></pre></div>
<p>如果需要切歌，可以在终端里输入fg，将后台进程调到前台，然后ctrl+C终止之，但是其实问题并没有得到彻底解决。假如你在终端A中听歌，此时你在终端B中工作并产生了切歌的想法，你在终端B中输入fg，afplay的进程并不会被调到前台，你还是得回到终端A去操作这一切，这并不是我们想要的结果。此时我们可以定义一个新的函数<code>n</code>，这个函数主要就是找出afplay的pid，然后使用kill向它发信号并终止该进程，这里使用INT信号，其效用等同于ctrl+C。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span><span class="fu"> n()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="va">pid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $2}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="bu">kill</span> -INT <span class="va">$pid</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">}</span></a></code></pre></div>
<blockquote>
<ol start="2" type="1">
<li>当我连续切歌时，随机性很差，因为文件是按文件名排序的，连续切歌时，时间戳增长不多，往往放来放去都是同一个人的歌，</li>
</ol>
</blockquote>
<p>显然单纯地使用时间戳并不是一个好主意，我们需要别的随机数，Shell其实本身就给我们提供了随机数函数，我们可以通过<code>$((RANDOM))</code>来调用。这里我依然使用了时间戳，我把时间戳和随机数乘起来得到新的随机数再使用，这完全是个人喜好问题，你只用<code>$((RANDOM))</code>也没有关系。这样一来，你在不停切歌的时候，歌曲就不会从随机播放变成了顺序播放了。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span><span class="fu"> m()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="ex">...</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="va">dummy1=$((</span>RANDOM<span class="va">))</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="va">timestamp=$(</span><span class="fu">date</span> +%s<span class="va">)</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="va">dummy=$(($dummy1</span>*<span class="va">$timestamp))</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="va">song_index=$(($dummy</span>%<span class="va">$song_num</span>+1<span class="va">))</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="ex">...</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">}</span></a></code></pre></div>
<blockquote>
<ol start="3" type="1">
<li>目前的播放器实在太佛系了，只能随机放歌，其实有时候我也会想定向检索一首歌的，</li>
</ol>
</blockquote>
<p>这个也很简单，这个播放器运转的流程是<strong>1.生成随机数–&gt;2.统计目录下歌曲数目–&gt;3.计算歌曲索引值–&gt;4.获取对应歌曲名–&gt;5.播放歌曲</strong>，我们可以在第二步和第四步里加一个过滤器，其实就是一个所有Unix系用户都熟悉的东西，<strong>grep</strong>，具体代码见下：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="va">BYel=</span><span class="st">'\e[0;33m'</span>;</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">function</span><span class="fu"> m()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="va">m_path=</span>~/Music/</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="va">keyword=</span><span class="st">"."</span>                                                     <span class="co"># default: play all the songs</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">if</span><span class="bu"> [</span> <span class="ot">-n</span> <span class="st">"</span><span class="va">$1</span><span class="st">"</span><span class="bu"> ]</span>; <span class="kw">then</span>                                            <span class="co"># play songs by keyword</span></a>
<a class="sourceLine" id="cb5-6" title="6">        <span class="va">keyword=</span><span class="st">"</span><span class="va">$1</span><span class="st">"</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="va">song_num=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ls</span> <span class="va">$m_path</span> <span class="kw">|</span> <span class="fu">grep</span> -i -e <span class="va">$keyword</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="va">)</span><span class="st">"</span>               <span class="co"># Total num of qualified songs</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="va">dummy1=$((</span>RANDOM<span class="va">))</span></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="va">timestamp=$(</span><span class="fu">date</span> +%s<span class="va">)</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="va">dummy=$(($dummy1</span>*<span class="va">$timestamp))</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="va">song_index=$(($dummy</span>%<span class="va">$song_num</span>+1<span class="va">))</span>                              <span class="co"># Generate a random song index</span></a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="va">song=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ls</span> <span class="va">$m_path</span> <span class="kw">|</span> <span class="fu">grep</span> -i -e <span class="va">$keyword</span> <span class="kw">|</span> <span class="fu">sed</span> -n <span class="st">"</span><span class="va">$song_index</span><span class="st">"</span>p<span class="va">)</span><span class="st">"</span>   <span class="co"># Get the name of the qualified song</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="bu">echo</span> -e <span class="st">"</span><span class="va">${BYel}$song</span><span class="st">"</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="ex">afplay</span> <span class="st">"</span><span class="va">$m_path$song</span><span class="st">"</span> <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="kw">}</span></a></code></pre></div>
<p>这样一来，我们就可以使用关键字检索我们要听的歌了，实际上，我们可以看作，每次听歌的时候，该播放器都临时生成了一张歌单，这个歌单是由所有满足你关键字的歌组成的。酷炫的是，由于我们使用了强大的grep，所以输入的关键字可以是充满想象力的正则表达式 ;)</p>
<blockquote>
<ol start="4" type="1">
<li>每首歌放完之后都要重新输入m才可以开始下一首，是否可以自动播放下一首。</li>
</ol>
</blockquote>
<p>这里需要用到while循环和wait，while(1)死循环就是为了一直播放音乐，wait主要是为了等待前面的命令执行完毕，在这里afplay什么时候执行完毕呢，就是一首歌放完的时候，所以正好一首放完就可以开始放下一首了。当然要注意这里不能让afplay后台了，因为这会使wait失效，此处我们令整个函数后台运行。为了保持之前我们只要在命令行里输入一个m就开始放歌的简易方式，我们重命名原函数为<code>music_by_keyword()</code>然后用一个<code>m()</code>函数将这个函数包裹起来，这样一来，它的运行方式就跟之前一样了。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">function</span><span class="fu"> m()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="ex">music_by_keyword</span> <span class="va">$1</span> <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">}</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="va">BYel=</span><span class="st">'\e[0;33m'</span>;</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">function</span><span class="fu"> music_by_keyword()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="va">m_path=</span>~/Music/</a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="va">keyword=</span><span class="st">"."</span>                                                         <span class="co"># default: play all the songs</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">if</span><span class="bu"> [</span> <span class="ot">-n</span> <span class="st">"</span><span class="va">$1</span><span class="st">"</span><span class="bu"> ]</span>; <span class="kw">then</span>                                                <span class="co"># play songs by keyword</span></a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="va">keyword=</span><span class="st">"</span><span class="va">$1</span><span class="st">"</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="kw">fi</span></a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="va">song_num=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ls</span> <span class="va">$m_path</span> <span class="kw">|</span> <span class="fu">grep</span> -i -e <span class="va">$keyword</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="va">)</span><span class="st">"</span>                   <span class="co"># Total num of qualified songs</span></a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="kw">while</span><span class="bu"> [</span> 1<span class="bu"> ]</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-16" title="16">        <span class="va">dummy1=$((</span>RANDOM<span class="va">))</span></a>
<a class="sourceLine" id="cb6-17" title="17">        <span class="va">timestamp=$(</span><span class="fu">date</span> +%s<span class="va">)</span></a>
<a class="sourceLine" id="cb6-18" title="18">        <span class="va">dummy=$(($dummy1</span>*<span class="va">$timestamp))</span></a>
<a class="sourceLine" id="cb6-19" title="19">        <span class="va">song_index=$(($dummy</span>%<span class="va">$song_num</span>+1<span class="va">))</span>                              <span class="co"># Generate a random song index</span></a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21">        <span class="va">song=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ls</span> <span class="va">$m_path</span> <span class="kw">|</span> <span class="fu">grep</span> -i -e <span class="va">$keyword</span> <span class="kw">|</span> <span class="fu">sed</span> -n <span class="st">"</span><span class="va">$song_index</span><span class="st">"</span>p<span class="va">)</span><span class="st">"</span>   <span class="co"># Get the name of the qualified song</span></a>
<a class="sourceLine" id="cb6-22" title="22">        <span class="bu">echo</span> -e <span class="st">"</span><span class="va">${BYel}$song</span><span class="st">"</span></a>
<a class="sourceLine" id="cb6-23" title="23">        <span class="ex">afplay</span> <span class="st">"</span><span class="va">$m_path$song</span><span class="st">"</span></a>
<a class="sourceLine" id="cb6-24" title="24">        <span class="bu">wait</span></a>
<a class="sourceLine" id="cb6-25" title="25">    <span class="kw">done</span></a>
<a class="sourceLine" id="cb6-26" title="26"><span class="kw">}</span></a></code></pre></div>
<p>最后，我们可以使用kill的信号量拓展一下这个播放器的功能，比如切歌／终止／暂停／继续：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">function</span><span class="fu"> n()</span> <span class="kw">{</span>  <span class="co"># next song</span></a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="va">pid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $2}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="bu">kill</span> -INT <span class="va">$pid</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">}</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="kw">function</span><span class="fu"> mm()</span> <span class="kw">{</span> <span class="co"># terminate afplay</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="va">pid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $2}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="va">ppid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $3}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="bu">kill</span> -INT <span class="va">$ppid</span> <span class="kw">&amp;&amp;</span> <span class="bu">kill</span> -INT <span class="va">$pid</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="kw">}</span></a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="kw">function</span><span class="fu"> ms()</span> <span class="kw">{</span> <span class="co"># music stop</span></a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="va">ppid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $3}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-14" title="14">    <span class="va">pid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $2}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="bu">kill</span> -TSTP <span class="va">$pid</span> <span class="kw">&amp;&amp;</span> <span class="bu">kill</span> -TSTP <span class="va">$ppid</span></a>
<a class="sourceLine" id="cb7-16" title="16"><span class="kw">}</span></a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="kw">function</span><span class="fu"> mc()</span> <span class="kw">{</span> <span class="co"># music continue</span></a>
<a class="sourceLine" id="cb7-19" title="19">    <span class="va">ppid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $3}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-20" title="20">    <span class="va">pid=</span><span class="st">"</span><span class="va">$(</span><span class="fu">ps</span> -ef <span class="kw">|</span> <span class="fu">grep</span> afplay <span class="kw">|</span> <span class="fu">grep</span> -v grep <span class="kw">|</span> <span class="fu">head</span> -1 <span class="kw">|</span> <span class="fu">awk</span> <span class="st">'{print $2}'</span><span class="va">)</span><span class="st">"</span></a>
<a class="sourceLine" id="cb7-21" title="21">    <span class="bu">kill</span> -CONT <span class="va">$pid</span> <span class="kw">&amp;&amp;</span> <span class="bu">kill</span> -CONT <span class="va">$ppid</span></a>
<a class="sourceLine" id="cb7-22" title="22"><span class="kw">}</span></a></code></pre></div>
<h2 id="演示">2. 演示</h2>
<p><img alt="play_music_in_terminal" src="../imgs/terminal_music_demo.png" style="height: 650px;"/></p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>用Lisp写slides</title><published>Jun 2, 2018</published><updated>2020-03-06T11:28:35Z</updated><link href="http://jujuba.me/posts/racket-slideshow.html"/><id>http://jujuba.me/posts/racket-slideshow.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">用Lisp写slides</h1>
<p class="date">Jun 2, 2018</p>
</header>
<p><img alt="Lisp logo" height="150" src="../imgs/lisp-logo.png" style="margin-left:60pt"/> <img alt="Scheme logo" height="150" src="../imgs/scheme-logo.png" style="margin-left:60pt"/> <img alt="Racket logo" height="150" src="../imgs/racket-logo.png" style="margin-left:60pt"/></p>
<h2 id="lisp-scheme-or-racket">0. Lisp, Scheme, or Racket?</h2>
<p>Lisp，诞生于1958年，世界上第二古老的编程语言，仅次于Fortran。在之后的漫长岁月里，Lisp发生了很多改变，也产生了很多所谓的“方言”，当现在的我们提到Lisp时，我们更多地是指Lisp系的语言。在这些“方言”中，最著名的莫过于Common Lisp和Scheme了。这篇文章要用到的语言叫做Racket，Racket之前叫做PLT Scheme，顾名思义Racket是由Scheme演化而来的，至于PLT的含义已不可考，一般认为是指<a href="https://stackoverflow.com/questions/13724714/what-does-the-plt-in-plt-scheme-now-called-racket-stand-for">Programming Language Team</a>。</p>
<p>我对Lisp的兴趣，甚至于说我对整个Programming Language Theory的兴趣，都来自于两件事。 一是我大一大二的时候沉迷于逆向破解，觉得<a href="https://www.hex-rays.com/products/ida/">IDA</a>这种软件实在是太神奇了，把要分析的程序丢进去，按一下F5居然就可以将一堆二进制转换成C语言的伪代码，我觉得这一定很困难吧，更不用说现代编译器对代码的各种优化了，这里面一定藏着编程的秘密 :) 第二件事是因为一个叫<a href="http://www.yinwang.org/">王垠</a>的人，我觉得程序员里不少人应该都听过他的名字。我是在大三的时候看到他的博客的，那时候的我就像发现了一个宝藏一样，每天都要读几篇他的文章（尽管我已经看了好多遍），看好几次他今天有没有更新博客，甚至连检查电脑连不连网都是用的<code>ping www.yinwang.org</code>，活脱脱一个小迷弟。当然了，很可惜的是，他无法成为我永远的偶像，如果真是那样，那只能说明我的水平停滞不前了，which is 非常不好的，就像他在<a href="http://www.yinwang.org/blog-cn/2014/08/11/genius">怎样成为一个天才</a>里说的：</p>
<blockquote>
<p>要成为天才，必须要能够打破别人设下的思维圈套。去除自己头脑里的各种权威，是非常重要的事情。你必须首先在心理上把自己放在跟本领域的权威平起平坐的地位，才能有效地对他们的想法做出判断和消化。我喜欢对权威显示出藐视的态度，就是这个原因，这是一种“矫枉过正”的方法。因为他们最开头在我心里还占有很重要的地位，为了把他们轰下去，我最开头是很激烈的藐视。到后来自己的认识因此迅速加深之后，才开始慢慢的理解到他们其中一些想法的启发意义。最后那种激烈的情绪逐渐消亡，他们在我心里也就变成了很普通的人。</p>
</blockquote>
<p>不过，我从他的博客里学到的那些珍贵的知识，却是可以使我受益终身的，正如他在<a href="http://www.yinwang.org/blog-cn/2017/11/01/power-of-reasoning">理性的力量</a>所里写到的，</p>
<blockquote>
<p>这些话有它们自己的地位，它们不属于我，不依赖于我，它们本身就是一种成就。如果有人想用我的话去说服另一个人，他不需要告诉他：“王垠说……” 他只需要告诉他是什么，为什么，就像转述一个定理一样。这就是为什么王垠打倒了很多人心中的权威，而他自己并没有成为新的权威。他说了如此多有重大价值的内容，却经常被一些刚学会 Python 的初学者鄙视。这就是所谓“上善若水” :p</p>
</blockquote>
<p>似乎扯得太远了，回到正题，王垠的博客里有好几篇写Lisp的文章，有兴趣的可以看一看，比如下面几篇：</p>
<ul>
<li><a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">怎样写一个解释器</a></li>
<li><a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax">谈语法</a></li>
<li><a href="http://www.yinwang.org/blog-cn/2013/03/26/lisp-dead-alive">Lisp 已死，Lisp 万岁！</a></li>
</ul>
<h2 id="slideshow">1. <a href="https://docs.racket-lang.org/slideshow/index.html">Slideshow</a></h2>
<p>Slideshow是一个Racket库，专门用来写presentation用的slides，作者是<a href="http://www.cs.utah.edu/~mflatt/">Matthew Flatt</a>和<a href="https://www.eecs.northwestern.edu/~robby/">Robby Findler</a>。</p>
<p>在macOS上，<a href="https://download.racket-lang.org/">安装Racket</a>的同时会自带slideshow，我们打开slideshow之后可以看到有一个Run Tutorial的选项，</p>
<p>Slideshow自带一套非常实用的教程，该教程本身就是用slideshow写的，我将该教程打印成了pdf，可以点击<a href="../resources/slideshow-tutorial.pdf">这里</a>查看slideshow写出来的效果。</p>
<p>Slideshow的语法非常简洁，比如下面的代码：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" title="1">(slide</a>
<a class="sourceLine" id="cb1-2" title="2">  #:name <span class="st">"Title Slide"</span></a>
<a class="sourceLine" id="cb1-3" title="3">  (titlet <span class="st">"Slideshow Tutorial"</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">  (blank)</a>
<a class="sourceLine" id="cb1-5" title="5">  (size-in-pixels</a>
<a class="sourceLine" id="cb1-6" title="6">    (bitmap (collection-file-path <span class="st">"PLT-206.png"</span> <span class="st">"icons"</span>)))</a>
<a class="sourceLine" id="cb1-7" title="7">  (blank)</a>
<a class="sourceLine" id="cb1-8" title="8">    (colorize (it <span class="st">"Press the spacebar to continue"</span>) <span class="st">"blue"</span>)</a>
<a class="sourceLine" id="cb1-9" title="9">  (comment <span class="st">"Welcome to Slideshow"</span>))</a></code></pre></div>
<p>会生成如下slide：</p>
<p><img alt="slideshow_0" src="../imgs/slideshow_0.png" style="height: 400px;"/></p>
<p>Slideshow拥有不俗的Text alignment能力：</p>
<p><img alt="slideshow_1" src="../imgs/slideshow_1.png" style="height: 400px;"/></p>
<p>也可以很好地显示代码和使用bullet point：</p>
<p><img alt="slideshow_1" src="../imgs/slideshow_2.png" style="height: 400px;"/></p>
<p>或者使用<code>alts</code>和<code>next</code>关键字来控制slide中内容出现的先后次序，<code>alts</code>关键字后接一个由list组成的list，每个list代表下一次点击后要显示的内容，需要注意的是下一个list中的内容会将上一个list中的内容给覆盖掉。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb2-1" title="1">(slide</a>
<a class="sourceLine" id="cb2-2" title="2"> #:title <span class="st">"Alternatives"</span></a>
<a class="sourceLine" id="cb2-3" title="3"> (para <span class="st">"Steps can break up a linear slide, but sometimes"</span></a>
<a class="sourceLine" id="cb2-4" title="4">            <span class="st">"you need to replace one thing with something else"</span>)</a>
<a class="sourceLine" id="cb2-5" title="5"> 'alts </a>
<a class="sourceLine" id="cb2-6" title="6"> (<span class="kw">list</span> (<span class="kw">list</span> </a>
<a class="sourceLine" id="cb2-7" title="7">        (para #:fill? <span class="dv">#f</span> <span class="st">"For example, replace this..."</span>))</a>
<a class="sourceLine" id="cb2-8" title="8">       (<span class="kw">list</span></a>
<a class="sourceLine" id="cb2-9" title="9">        (para #:fill? <span class="dv">#f</span> <span class="st">"... with something else"</span>)</a>
<a class="sourceLine" id="cb2-10" title="10">        'next</a>
<a class="sourceLine" id="cb2-11" title="11">        (blank)</a>
<a class="sourceLine" id="cb2-12" title="12">        (item <span class="st">"An"</span> (code 'alts) <span class="st">"in a sequence"</span></a>
<a class="sourceLine" id="cb2-13" title="13">                   <span class="st">"must be followed by a list of lists"</span>)</a>
<a class="sourceLine" id="cb2-14" title="14">        (item <span class="st">"Each list is a sequence, a different conclusion for the slide's sequence"</span>))))</a></code></pre></div>
<p>如果不想将旧的内容覆盖掉，可以使用<code>next</code>关键字：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb3-1" title="1">(slide</a>
<a class="sourceLine" id="cb3-2" title="2"> #:title <span class="st">"Steps"</span></a>
<a class="sourceLine" id="cb3-3" title="3"> (item <span class="st">"Suppose you want to show only one item at a time"</span>)</a>
<a class="sourceLine" id="cb3-4" title="4"> 'next</a>
<a class="sourceLine" id="cb3-5" title="5"> (item <span class="st">"In addition to body picts, the"</span> (code slide) </a>
<a class="sourceLine" id="cb3-6" title="6">            <span class="st">"functions recognize certain staging symbols"</span>)</a>
<a class="sourceLine" id="cb3-7" title="7"> (item <span class="st">"Use"</span> (code 'next) <span class="st">"in a sequence of"</span> (code slide)</a>
<a class="sourceLine" id="cb3-8" title="8">            <span class="st">"arguments to create multiple slides, one"</span></a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="st">"containing only the preceding content, and another"</span></a>
<a class="sourceLine" id="cb3-10" title="10">            <span class="st">"with the remainder"</span>)</a>
<a class="sourceLine" id="cb3-11" title="11"> 'next</a>
<a class="sourceLine" id="cb3-12" title="12"> (blank)</a>
<a class="sourceLine" id="cb3-13" title="13"> (colorize</a>
<a class="sourceLine" id="cb3-14" title="14">  (para #:fill? <span class="dv">#f</span></a>
<a class="sourceLine" id="cb3-15" title="15">        (code 'next) <span class="st">"is not tied to"</span> (code item)</a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="st">", though it's often used with items"</span>)</a>
<a class="sourceLine" id="cb3-17" title="17">  <span class="st">"blue"</span>))</a></code></pre></div>
<h2 id="latex-in-slideshow">2. <a href="https://docs.racket-lang.org/slideshow-latex/index.html">LaTeX in slideshow</a></h2>
<p>写slides的时候往里面插入LaTeX是一个非常常见的需求，最近keynote发布了新版本，开始原生支持LaTeX了，这个特性还是很棒的，虽然迟来了很多年 :)</p>
<p>有人也为slideshow写了一个package叫做<a href="https://github.com/jeapostrophe/slideshow-latex">slideshow-latex</a>，这个包可以让你在slideshow中插入LaTeX公式，其本质是调用了latex来生成一个dvi文件，再调用dvipng将其转换为png文件并插入slide中。这个包有些亟待解决的问题，比如生成的图片的清晰度不够，以及使用该包之后会导致slideshow将slides转为pdf时失败（<code>slideshow --print example.rkt</code>），而且作者最近一次更新这个包是在三年多以前，所以我也并不指望作者会修正这个bug。</p>
<p>这个包可以通过raco来安装，raco是属于Racket的command-line tool，macOS下可以通过homebrew来进行安装，</p>
<pre class="shell"><code>brew install raco</code></pre>
<p>然后通过raco来安装slideshow-latex，</p>
<pre class="shell"><code>raco pkg install slideshow-latex</code></pre>
<p>在macOS上，要使用该包，必须更改latex和dvipng的默认路径，位于<code>slideshow-latex/slideshow/latex/latex2bitmap.rkt</code>的<a href="https://github.com/jeapostrophe/slideshow-latex/blob/master/slideshow/latex/latex2bitmap.rkt#L42">42-45行</a>。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb6-1" title="1"><span class="co">;; Default paths</span></a>
<a class="sourceLine" id="cb6-2" title="2">(define latex-path (make-parameter (find-executable <span class="st">"latex"</span> <span class="st">"/usr/bin"</span>)))</a>
<a class="sourceLine" id="cb6-3" title="3">(define dvipng-path (make-parameter (find-executable <span class="st">"dvipng"</span> <span class="st">"/usr/bin"</span>)))</a>
<a class="sourceLine" id="cb6-4" title="4">(define cache-path (make-parameter (find-system-path 'temp-dir)))</a></code></pre></div>
<p>设置好之后，就可以在slideshow中使用LaTeX了，使用语法非常简单，就跟原生LaTeX差不多。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb7-1" title="1">($<span class="st">"</span><span class="sc">\\</span><span class="st">N"</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">($$<span class="st">"</span><span class="sc">\\</span><span class="st">int_{-</span><span class="sc">\\</span><span class="st">infty}^</span><span class="sc">\\</span><span class="st">infty e^{-x^2}</span><span class="sc">\\</span><span class="st">,dx"</span>)</a></code></pre></div>
<h2 id="conclusion">3. Conclusion</h2>
<p>总结一下就是，slideshow是一个还不错的写slides的工具，很适合写写简单简洁的slides。同时它也可以作为练习一个Lisp系语言的方式，通过阅读slideshow以及slideshow-latex的源码，我们也可以感受到高手是如何使用Racket写软件的。随着自己的Racket水平的提升，说不定我能在使用slideshow的过程中寻找到更多的乐趣 :)</p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>飘来飘去，就这么飘来飘去</title><published>Oct 12, 2019</published><updated>2020-03-06T11:20:43Z</updated><link href="http://jujuba.me/posts/roaming-in-the-world.html"/><id>http://jujuba.me/posts/roaming-in-the-world.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">飘来飘去，就这么飘来飘去</h1>
<p class="date">Oct 12, 2019</p>
</header>
<p><img alt="Master of the future" height="250" src="../imgs/master-of-the-future.jpg"/></p>
<p><a href="https://www.youtube.com/watch?v=iWaQKda4uQE">羅大佑 - 未来的主人翁</a></p>
<p>读了phd之后我一头扎进论文与代码中，整日思考如何才能更好地完成老板的任务，渐渐养成了很不健康的生活习惯，晚上三四点才睡觉，睡到早上九点十点又起来干活。美国的生活与瑞典不同，没有那种均匀分布的超市，在美国想省钱最好的办法就是隔一两周去Costco买一大堆东西回来，于是我的生活就是，每周七天都在干活，周末找一个下午去一次超市，买上一车的东西然后吃上一两周。来了一年了，也没投入过什么娱乐活动，生活非常贫瘠，时常回忆起在瑞典在欧洲的日子，自由又轻松，这种时候就看看头上的天空困惑着，我们真的是生活在同一片蓝天下吗？经常很想回欧洲看看，但是无奈美国的签证已经到期，重新签证的风险太高，新来的学弟被check了99天才拿到签证，我只能叹一口气，并且觉得自己失去了翅膀，生活太过无聊。</p>
<p>有一天我对我本科的老师说，phd对我来说是个牢笼，到期的签证就是牢笼上的天花板，我们这一代人为了学到更好的知识，过上更好的生活，不得不漂洋过海，来到遥远的地方，却仍不知道应该在何处安放自己。这让我想起我在罗马碰到的两兄弟，我是如此羡慕他们，他们生在罗马，长在罗马，在罗马上了小学，中学，大学，在罗马读着phd… 曾经我觉得在这世界上飘来飘去很有趣，可以看遍这世界的角角落落，可是现在我才意识到，一个人总有飘累的时候，飘累的时候人应该回家吧，可是我的家在哪里呢？我发现我找不到安放我灵魂的地方。</p>
<p>以前我总是兴致勃勃地想，我要去世界上的很多很多地方，慢慢看慢慢体会，直到找到一个适合我的地方，然后停留在那里，又或者满地球的流浪。老师说我是成熟了，我不知道，我觉得我只是累了，读phd并没有带给我快乐，反而使我陷入了深深的疲惫以及自我怀疑。想到在瑞典的时候，我跟导师说我准备去美国读书了，他问我，你以后打算回国（中国）吗？我说怎么可能回去，你没听说吗，我们的president都变成emperor了。他只是说，哦那其实并不重要。那时候的我并不能理解，就像我并不理解他一个美国top15出来的phd为何会来到这个瑞典的本地学校当lecturer，后来我才明白他没说出口的句子应该是，只要你觉得那个地方合适，你就留下来好好生活吧。看看他的履历，印度到美国到英国到瑞典，一路走来，其实我们都是这世界上不安的灵魂，我们并没有那么幸运，出生在属于自己的罗马，我们在这世界上飘来飘去，都想要寻找属于自己的一个天地。</p>
<p>飘来飘去，就这么飘来飘去。</p>
<hr/>
<p>Update:<br/>
最近看了两个视频，一个<a href="https://www.youtube.com/watch?v=UJh0Nq2ovxY">关于美国的偷渡客</a>，一个是<a href="https://www.youtube.com/watch?v=9cmy_kwUNxs">关于国内的这些打工者</a>。看吧，其实我们都在流浪，都很孤单。</p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>Photo from Stockholm</title><published>Apr 17, 2018</published><updated>2020-03-06T11:20:44Z</updated><link href="http://jujuba.me/posts/stockholm-visit.html"/><id>http://jujuba.me/posts/stockholm-visit.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">Photo from Stockholm</h1>
<p class="date">Apr 17, 2018</p>
</header>
<h2 id="kth-main-campus">KTH Main campus</h2>
<p><img alt="KTH scene" height="550" src="../imgs/kth_scene_1.png"/> <img alt="KTH scene" height="550" src="../imgs/kth_scene_2.png"/> <img alt="KTH scene" height="550" src="../imgs/kth_scene_3.png"/> <img alt="KTH scene" height="550" src="../imgs/kth_scene_4.png"/> <img alt="KTH scene" height="550" src="../imgs/kth_scene_5.png"/> <img alt="KTH scene" height="550" src="../imgs/kth_scene_6.png"/></p>
<h2 id="kth-kista">KTH KISTA</h2>
<p><img alt="KTH scene" height="550" src="../imgs/kth_kista_scene_1.png"/> <img alt="KTH scene" height="550" src="../imgs/kth_kista_scene_2.png"/></p>
<h2 id="uppsala">Uppsala</h2>
<p><img alt="Uppsala scene" height="550" src="../imgs/uu_scene_1.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_2.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_3.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_4.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_5.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_6.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_7.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_8.png"/> <img alt="Uppsala scene" height="550" src="../imgs/uu_scene_9.png"/></p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>自举的启发</title><published>Sep 1, 2018</published><updated>2020-03-06T11:20:42Z</updated><link href="http://jujuba.me/posts/inspiration-of-bootstraping.html"/><id>http://jujuba.me/posts/inspiration-of-bootstraping.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">自举的启发</h1>
<p class="date">Sep 1, 2018</p>
</header>
<p><img alt="bootstrap" src="../imgs/bootstrap.png" style="height: 300px;"/></p>
<p><strong>了解编译器自举的读者可以直接跳到分割线以下看。</strong></p>
<p>构建编译器过程中有个有趣的概念，叫做自举（<a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)">Bootstrapping</a>）。大意就是说，假设我要创造一门X语言，那我必然要为X语言写一个编译器or解释器，如果这个编译器就是用X语言写的，那么这个用X语言写X语言编译器的过程就是自举。当然现实并没有这么简单，因为写编译器之时，X语言并不存在，所以也无法用X语言写编译器，这就陷入了一个先有鸡还是先有蛋的困境。常见做法是：</p>
<ul>
<li>用另一种语言（如C）完成X语言的编译器的一部分，不需要太复杂，只需要能编译X语言的一个核心子集即可，</li>
<li>用X语言写出X语言编译器，之前面临的问题是没有编译器能将X语言源码变成二进制代码，但由于此时我们有了C语言写出来的编译器，我们就可以得到X语言写出的编译器的二进制代码了，</li>
<li>丢到C语言实现的编译器，用X语言实现的编译器继续拓展迭代下一个版本的编译器，直到完成。</li>
</ul>
<p>不常见的做法请见<a href="https://www.zhihu.com/question/28513473/answer/76068366">此处</a>。</p>
<hr/>
<p>好了科普完毕，这些其实都不是我想说的，我想说的是我今天突然意识到自举这个概念在生活中重要性。</p>
<p>比如学英语的过程其实应该是自举的过程，可是有多少人学了十几年还没开始自举呢？学英语的自举过程就应该是，一开始我们使用中文去学英语，当学完了英语的一个核心子集的时候，我们就应该使用英语去解释英语，一个简单的做法就是使用英英字典。再比如说，出国在外和人交谈，当对方说了一个你不懂的词的时候，你不应该掏出手机，再请对方一个个字母地拼出这个词，然后在手机上查出这个词的中文意思，正确的做法应该就是请他用英语中的其他词来解释这个词。</p>
<p>换个角度思考，C语言代表了舒适区，而X语言代表着新的领域，自举的过程也许更痛苦一些，但是也会让人成长得更快。</p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>A thinking reed</title><published>Mar 21, 2018</published><updated>2020-03-06T11:20:44Z</updated><link href="http://jujuba.me/posts/thoughts.html"/><id>http://jujuba.me/posts/thoughts.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">A thinking reed</h1>
<p class="date">Mar 21, 2018</p>
</header>
<p><img alt="Man is but a reed, the weakest of nature, but he is a thinking reed." height="400" src="../imgs/reed.png"/></p>
<pre class="text"><code>勇气很重要，这些年来我看到很多人——其实大家都有着差不多的智商，接受着差不多的教育，但是大家的轨迹却不尽相同，我可能是其中过得还行的那一个。我觉得很重要的一点就是，在很多时候我比较勇敢，在发现机会之后愿意主动抓住这些机会。勇气有很多种，此时在我脑海里盘旋的一种勇气叫做直面过去的勇气。比如说，像很多人一样，我也搭过很多次博客，而且每次都因为各种各样的原因而停止了。其中一个重要的原因就是没有勇气直视自己从前写下的文字，觉得幼稚，觉得愚蠢，觉得暴露了这些从前的文字让自己感到羞耻。不过现在的我更倾向于留下这些文字作为记录，过去的幼稚不应该成为一种羞耻，我想记住那个幼稚的自己。更何况，世界上还有许许多多的人，他们正处于我从前的那个幼稚的水平，或者正朝着我眼中所谓的幼稚水平前进，我希望我能用这种方式帮助他们。
-- 17:59, February 21, 2020</code></pre>
<pre class="text"><code>老师让我总结一下我的Master申请，我想了一两分钟，然后说：

从实力来说，我觉得自己很强；从申请材料来看，我觉得自己很弱；从申请结果来说，我觉得自己很幸运；从努力程度来说，我觉得我真的挺一般的。

当时想着自己回复得太着急了，深思熟虑一下应该能想出更好的回复的，但是当冷静下来之后，却感觉这四条似乎也算是完整地概括了我的申请季了吧 ;)

-- 20:48, April 19, 2018</code></pre>
<pre class="text"><code>&gt; A number of these phenomena have been bundled under the name "Software Engineering". As economics is known as "The Miserable Science", software engineering should be known as "The Doomed Discipline", doomed because it cannot even approach its goal since its goal is self-contradictory. Software engineering, of course, presents itself as another worthy cause, but that is eyewash: if you carefully read its literature and analyse what its devotees actually do, you will discover that software engineering has accepted as its charter "How to program if you cannot.". -- Dijkstra

我的本科实行计算机大类的制度，简而言之，大一上学期到大二上学期大家都没有明确的专业，都叫做计算机大类，等到大二上学期结束，大家就会开始选择自己的专业：计算机科学，软件工程或者网络工程。当年的我觉得自己真是好喜欢写代码啊，软件工程这个专业一听就是写代码的吧（然而我连培养方案都没认真看懂），于是我毫不犹豫地选择了软件工程专业。现在临近毕业之际，看到Dijkstra的言论真是哑然失笑，他说软件工程是穷途末路的领域，其本质可以总结为How to program if you cannot。他的言论解答了我大三时的困惑，当时我在上“软件工程经济学”，“软件项目管理”等课程的时候就会觉得，wtf我为什么要上这些东西。这种东西根本就没什么好教的，好的程序员之间就是会互相合作的，你动用各种方法去强迫他们是很可悲的。这个观点被我后来在网上看到的抱怨所验证，像敏捷开发scrum这种东西，在中国的业界成为了压榨程序员的一种手段。

个人来说，我觉得软件工程在现实中的语义可以概括为：如何高效地驱使一群平庸的程序员在一起合作并产生最大的效益值&lt;del&gt;，手段往往是残酷的&lt;/del&gt; :)

-- 00:36, April 8, 2018</code></pre>
<pre class="text"><code>有些人到了自己人生的某个阶段（e.g.20岁）就会开始觉醒，认识到自己与不同阶级同龄人的差距，并感叹自己之前的人生过得多么“不懂事”，其实很多时候，这种事都无法改变。简而言之，当你还小还没有能力没有经验站在一个高度为自己写下一个十年二十年计划的时候，你的父母是唯一能为你做这些事的人，如果他们没有做，那么你的人生就会过得非常随机。随机的意思是，你20岁之前的人生会轻易地被一些事所改变，你所遇见的朋友、老师、恋人，会在很大程度上左右你的人生，而年幼的你并不知道如何去遇见更好的人，或者甚至无法分辨什么才算是好。从系统的角度来看，这一点也不Robust :)

&gt; There is only one heroism in the world: to see the world as it is, and to love it. -- Romain Rolland

-- 10:50, March 24, 2018</code></pre>
<pre class="text"><code>曾经我以为编程能力就是一切，写得一手好代码就可以在这世界上赢得很多的尊重，曾经是指在我大二大三的时候；后来我失望地觉得编程能力只是一个微不足道的东西，因为人们更倾向于用可标化的东西来衡量你，GPA、TOEFL、GRE、Paper...我觉得我都还没有得到展示我自己所谓编程能力的机会，就被拒绝了，后来指的是我在准备申请Master的那段时间；如今我认为我终于正视了这一切，编程既谈不上多么高贵，也说不上多么卑微，它只是一个普通的技能，和木工、电工、摄影、厨艺都没有什么区别。我对它有过的热情以及失望，都来源于我对它的迷恋，而这本质上和爱上一个小姑娘并没有什么区别 :)

-- 21:30, March 7, 2018</code></pre>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>瑞典生活总结</title><published>Jun 21, 2018</published><updated>2020-03-06T11:20:42Z</updated><link href="http://jujuba.me/posts/life-in-sweden.html"/><id>http://jujuba.me/posts/life-in-sweden.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">瑞典生活总结</h1>
<p class="date">Jun 21, 2018</p>
</header>
<p><img alt="flag of sweden" src="../imgs/flag_of_sweden.png" style="height: 200px;"/></p>
<h2 id="overview">0. Overview</h2>
<p>在瑞典呆了十个月，迄今为止人生中最美好的十个月之一，我觉得我有必要记录一些东西，碰到的美好的事情也好，日常琐碎的衣食住行也好，随便写点吧。</p>
<p>先说几个我知道的事实感受一下瑞典吧，449,964平方公里，1000万左右人口，其中100万外来移民。可以拿浙江比一下，浙江面积104,141平方公里，5657万的人口，瑞典面积是浙江的四倍多，人口却只有五分之一都不到。同时，瑞典有着超过60%的森林覆盖率，地广人稀，又有各种森林，如果在瑞典的话，充分跟大自然接触是一件必须的事。</p>
<h2 id="吃">1. 吃</h2>
<p>我到瑞典之前一个菜也没做过，也没烧过饭，不过我还是非常适应地生活了下来，这可能是由于我对中餐没有什么执念吧。瑞典的食物都非常健康，或者说原始也行，对于能够欣赏食物本身味道的人来说，瑞典的食物还是很不错的。最近我回到国内，明显就感觉国内的食物油盐太重，吃不下去，非常怀念瑞典的食物。</p>
<h3 id="早饭">1.1 早饭</h3>
<p>刚去的时候早饭基本就吃吐司+煎蛋／煎培根／果酱／蔬菜等，后来发现买一大袋吐司经常吃不完坏掉，就开始尝试别的了，比如麦片／玉米片／坚果（？就是那种各种乱七八糟东西混在一起的，包括但不限于葡萄干／椰子干／核桃仁等等等等），然后拌一下酸奶／鲜奶就完事了。或者直接前一天晚上买做好的面包，第二天早上起来吃一个就行了。后期我的胃口变小了，一般就吃两个白煮蛋，再喝点酸奶，吃两三个肉丸（瑞典肉丸真的很好吃，我一天到晚当零食吃）。</p>
<h3 id="午饭以及晚饭">1.2 午饭以及晚饭</h3>
<p>第一个学期我很忙，作息表基本上就是早上8点出门，中午12点吃饭，下午3点吃一块巧克力（买那种体积大热量低的，增加饱腹感），晚上7点图书馆关门，我也就回去吃饭，睡一会，然后接着干活。那段时间中午都吃的学校的沙拉，不得不说学校的沙拉真的很健康，一开始还觉得不习惯，后来天天吃就觉得，真的还挺好吃的。</p>
<center>
<img alt="sweden lunch" src="../imgs/sweden-lunch-0.jpg" style="height: 300px;margin-left:20pt;"/> <img alt="sweden lunch" src="../imgs/sweden-lunch-1.jpg" style="height: 300px;margin-left:20pt;"/> <img alt="sweden lunch" src="../imgs/sweden-lunch-2.jpg" style="height: 300px;margin-left:20pt;"/>
</center>
<p>后来空一点的话，一般就回去自己做了，一般就吃面，放点蔬菜放点肉什么的，平均下来一餐应该40SEK就能解决了，还是很便宜的。瑞典的三文鱼便宜又好吃，有段时间我连吃了一周三文鱼，烧法很简单，就是柠檬水和黑胡椒腌10分钟，然后放锅里煎1分钟，我一般只煎三面，朝上的那一面不煎，这样一餐大概也就60SEK吧，还是很好的。</p>
<center>
<img alt="sweden salmon" src="../imgs/salmon.png" style="height: 400px;"/> <img alt="sweden salmon" src="../imgs/salmon1.png" style="height: 400px;margin-left:20pt;"/>
</center>
<p>至于出去吃，一般都是80-150SEK，我觉得还行，我在村里的自助餐一般也是这个价，跟普通的食物没啥大区别。</p>
<h3 id="出门">2. 出门</h3>
<p>出门这个事其实我没啥发言权，虽然我还跑了挺多地方的，但是我走的那天有人告诉我说瑞典貌似有学生优惠码，有时候从我那村里坐到斯京才花60SEK，当时我的内心 wtf??? 我买的票都是三到五百不等的，心好痛。瑞典的火车速度我觉得还行，100多公里每小时吧，国内跑跑挺方便的。瑞典进火车站倒是很方便，也不用安检，我就住在火车站走路5分钟距离的地方，一半就开车之前10分钟稍微整理一下就可以出门了，赶到车站直接上车就行了。</p>
<p>瑞典查票不是很严格，我有好多次火车坐完了都下车了也没人来查票。瑞典的官方火车App很不错，可以直接在上面买票，买完会有一个二维码，检票的时候把二维码给检票员看一下就行了，App还会实时推送这趟火车的行驶进度以及意外情况（如果有的话）。</p>
<p>至于飞机，26岁以下的人都可以去芬兰航空或者北欧航空购买青年票，有时候价格便宜到不敢相信，我记得12月有次我看北欧航空上的机票，回国往返加起来才2000+，非常实惠，去欧洲还是要趁早 XD</p>
<h3 id="杂项">3. 杂项</h3>
<ul>
<li>瑞典的大学之间合作很紧密，我之前有个Machine Learning的项目要做，但是我的Mac性能不够，我就跟我的导师说这件事。我的导师告诉我去借一台Super Computer，让我直接发邮件给service center就行了，就算这个学校没有Super Computer，你也可以从别的学校去借，比如CTH或者KTH。然后我就发了封邮件，过了两天就给了我一个超算的账号，144核，500G内存以及20T的硬盘空间。</li>
</ul>
<p>(To be continued…)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>瑞典硕士申请不完全攻略</title><published>Apr 11, 2018</published><updated>2020-03-06T11:20:42Z</updated><link href="http://jujuba.me/posts/apply_master_in_sweden.html"/><id>http://jujuba.me/posts/apply_master_in_sweden.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">瑞典硕士申请不完全攻略</h1>
<p class="date">Apr 11, 2018</p>
</header>
<p><img alt="Result of my application" height="350" src="../imgs/my_sweden_ms_ad.png"/></p>
<h2 id="前言">0. 前言</h2>
<p>前段时间自己被KTH的CS Master录取了，感觉自己一年多来的努力终于得到了回报。回忆我自己申请瑞典研究生的过程，我觉得网上关于瑞典申请的信息并不丰富，大部分只是抄来抄去的过时信息而已，在这里我想写一些网上不太常见但是能帮助大家去瑞典留学的东西。</p>
<p>我还是说一下我的背景吧，我来自帝都某双非，很多专业都还是二本招生的那种双非，均分86。我知道这一点对于很多人来说是很inspiring的，因为我还记得一年多之前我在寄托上搜个帖子都要加个双非关键字的样子 :)</p>
<p>当然我在瑞典申请很重要的一点是我大四在瑞典交换，我的本科不怎么样，所以在瑞典交换的学校也是一所默默无闻的学校。但是这边的师资水平，其实是很不错的，至少完爆了我的本科。瑞典学校特别相信自己系统里的人，我交换时在这边拿了两封强推，其中一个推荐人在KTH当过postdoc，直接让我觉得瑞典录取没问题了。所以如果你真的交换过来了，一心冲着拿推荐信去吧，至少我在我推荐人的课上拿的都是满绩，连作业都是浮夸地用LaTeX写的。当然这个学校有他自己的问题，招来的学生水平参差不齐，方差太大，比我本科还大，管理上也会有一些问题，不过我还是在这里学到了很多东西。</p>
<h2 id="选校">1. 选校</h2>
<h3 id="如何查看历年录取数据">1.1 如何查看历年录取数据</h3>
<p>其实瑞典每年都会把所有学校的申请数据公开的，今年4.6出的结果，我4.8看到数据已经公开了。数据可以在 <a href="http://statistik.uhr.se/">statistik.uhr.se</a> 上看到，下面我说下这个到底怎么用。</p>
<p>首先这个网站是瑞典语的，我使用Chrome的自动翻译将其翻译成英文，然后假设我要看KTH18年Master的录取情况，我需要选择Master18这个学期，并选择学校，Kungliga Tekniska högskolan就是KTH。注意上面的free text就是自定义搜索，问题是你需要用瑞典语来搜索，用英文是不行的。比如说你要搜Computer Science，你要先把它翻译成瑞典语datalogi，然后才能放到搜索框里。当然每个学校的Computer Science项目的瑞典语其实是不一样的，至少KTH的CS的瑞典语是datalogi。</p>
<figure>
<img alt="How to search KTH Master 18 application data" src="../imgs/kth_ms18.png"/><figcaption>How to search KTH Master 18 application data</figcaption>
</figure>
<p>搜索结果如下图所示，这里主要列出了项目的申请人总数与第一志愿的申请人数量，这两个数据很有用。这里先扯一下瑞典的申请系统，瑞典申请硕士是按志愿来的，一个人能填4个志愿，然后录取也是按顺序来的，如果四个项目你都能被录取，那么你会被录取到第一志愿，剩余的志愿会被删除。然后还有两点需要综合考虑：</p>
<ol type="1">
<li>瑞典的系统交一份钱就可以填四个志愿，别人我不知道，至少我是顺手把四个志愿都填满了的。</li>
<li>瑞典的项目大部分是只有第一志愿才有奖学金。</li>
</ol>
<p>我得出的结论就是，申请人总数并不能很好地反映这个项目竞争的激烈程度，考虑第一志愿的申请人数量应该是更好的选择，特别是要追求奖学金的人。</p>
<figure>
<img alt="KTH Master 18 application data" src="../imgs/KTH_ms18_search_result.png"/><figcaption>KTH Master 18 application data</figcaption>
</figure>
<p>除了申请人数，还需要看录取人数，录取人数查看方法如下图所示，选择selection 1并选择Total number of admissions。图中admitted的就是被录取，reserved就是在waiting list上，瑞典的waiting list大部分时候都是另一种rejection，从图上可以看到waiting list的人数比admitted的人数还多是一件很正常的事 :)</p>
<figure>
<img alt="KTH Master 18 admission data" src="../imgs/KTH_ms18_ad_search_result.png"/><figcaption>KTH Master 18 admission data</figcaption>
</figure>
<h3 id="如何解读历年录取数据">1.2 如何解读历年录取数据</h3>
<p>下面以CTH和KTH的2018年的CS项目为例说明如何解读数据：</p>
<p><img alt="KTH CS Master 18 application data" src="../imgs/kth_ms18_cs_data.png"/> <img alt="KTH CS Master 18 admission data" src="../imgs/kth_ms18_cs_ad_data.png"/> <img alt="CTH CS Master 18 application data" src="../imgs/cth_ms18_cs_data.png"/> <img alt="CTH CS Master 18 admission data" src="../imgs/cth_ms18_cs_ad_data.png"/></p>
<p>上面的数据太乱，直接看下面的表格即可：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">[University]</th>
<th style="text-align: center;">[number of applicants]</th>
<th style="text-align: center;">[1st hand seeker]</th>
<th style="text-align: center;">[admitted]</th>
<th style="text-align: center;">[reserved]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">KTH</td>
<td style="text-align: center;">1041</td>
<td style="text-align: center;">523</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">77</td>
</tr>
<tr class="even">
<td style="text-align: center;">CTH</td>
<td style="text-align: center;">506</td>
<td style="text-align: center;">183</td>
<td style="text-align: center;">33</td>
<td style="text-align: center;">69</td>
</tr>
</tbody>
</table>
<p>如果只看申请总人数和录取的关系，可以得到如下录取率：</p>
<ul>
<li>KTH: admitted / number of applicants = 64 / 1041 = 6.15%</li>
<li>CTH: admitted / number of applicants = 33 / 506 = 6.52%</li>
</ul>
<p>乍一看两个学校的录取率是差不多的，不过因为瑞典的志愿机制，也许有很多像我一样的人，并没有把CTH的CS放在第一志愿（我放在第三志愿），所以导致这个录取率并不那么有说服力，如果我们计算第一志愿人数和录取的关系，就会发现CTH的竞争并没有KTH那么激烈。</p>
<ul>
<li>KTH: admitted / 1st hand seeker = 64 / 523 = 12.23%</li>
<li>CTH: admitted / 1st hand seeker = 33 / 183 = 18.03%</li>
</ul>
<p>再考虑到KTH和CTH的奖学金基本只给第一志愿的选手以及CTH的奖学金数目大于KTH的奖学金数目（可自行证实，CTH有Volvo奖学金以及75% tuition waive），所以申请CTH对于很多人来说可能都是一个更合适的选择。</p>
<p>以上只是对录取数据的初步解读。</p>
<h2 id="一些材料问题">2. 一些材料问题</h2>
<h3 id="语言成绩">2.1 语言成绩</h3>
<p>其实来了瑞典之后，你就会发现瑞典真的很平和，不怎么competitive，托福雅思也是考到一定的分就行了，考得很高跟刚好过线没什么区别。这里主要说一下瑞典录取怎么看待英语成绩，托福和雅思是分级的，一共就5/6/7三级。以托福为例，过了100分就是English 7最高级了，120分的托福也依然是English 7，说这些只是希望托福低的人别紧张。</p>
<p>IELTS Academic</p>
<ul>
<li>For English 7: an overall mark of 7.0 and no section below 6</li>
<li>For English 6: an overall mark of 6.5 and no section below 5.5</li>
<li>For English 5: an overall mark of 5.5 and no section below 5.0</li>
</ul>
<p>TOEFL IBT</p>
<ul>
<li>For English 7: Score of 20 (scale 0-30) in written test, total score of 100</li>
<li>For English 6: Score of 20 (scale 0-30) in written test, total score of 90</li>
<li>For English 5: Score of 17 (scale 0-30) in written test, total score of 72</li>
</ul>
<p>以上数据来自UA：<a href="https://www.universityadmissions.se/en/All-you-need-to-know1/Applying-for-studies/English-requirements/Internationally-recognized-English-test/">Reference</a></p>
<p>其实有个waive语言成绩的方法，在瑞典拿到30学分之后，可以waive语言成绩。瑞典一学期就是30学分，也就是说，你在这学一学期没挂科，拿了全部学分，就能waive语言成绩，具体算作哪个English等级不清楚，目测是最高级7。其他北欧国家的30学分似乎也可以，不过我不确定，所以来过北欧交换的人，是可以通过这个方式来尝试waive语言成绩的。当然最保险的选择是把语言成绩考出来，因为政策每年都在变，我有个同学就没考语言，想申乌普萨拉的某个项目，结果今年刚好不接受这种waive方式了 :) 如果实在没考出来又有北欧学分，发邮件问吧，应该会有希望的。</p>
<h3 id="motivation-letter-personal-statement">2.2 Motivation letter (Personal Statement)</h3>
<p>我觉得这个还是很重要的，我申了美国以及欧洲加起来12个学校，都没有找过中介，如果你申瑞典，那更不用找中介了，因为瑞典申请真的相对来说很简单的。瑞典真的是一个充满人文关怀的地方，在我交换的地方，想要联系教授其实挺方便的，可以直接过去drop in或者发个邮件预约，教授都挺友好的。我的Personal Statement就是我的推荐人帮我看的，我当时疯狂被拒加眼睁睁地看别人拿ad，然后我就把我的文书给我的推荐人看了，他看完之后就对我说，“Why not find me earlier? I can see why you are on the waiting list”，后来他给了我个提纲，我照着重写了，然后补申了三个学校录了两个 :) 其实文书内容也差不多，就是我之前脑袋里有n种想法互相在打架，写的太乱了，明确了一种架构之后再写真的好很多。我把提纲也放出来参考一下吧：</p>
<ul>
<li>What really interests you?</li>
<li>What are you good at?
<ul>
<li>evidence</li>
</ul></li>
<li>Why are you qualified?
<ul>
<li>prerequisite
<ul>
<li>e.g. Full grade on algorithm course</li>
<li>e.g. Research experience</li>
</ul></li>
</ul></li>
<li>What is your vision for your own education</li>
</ul>
<h3 id="reference-letter">2.3 Reference letter</h3>
<p>对于推荐信，我有一个不靠谱建议，虽然学校都写明了推荐信的数量要求（一般欧洲两封美国三封），但是多交几封推荐信似乎只有好处没有坏处，因为我觉得学校可以通过这几封的推荐信来更全面地评价你这个人。其实有这个想法是因为在gradcafe上看到几个印度人说自己交了5封甚至更多的推荐信，瞬间感觉自己的想象力被限制得好惨。Anyway，我的三封推荐信都不是我写的，如果自己写的话，感觉可以从多几个方面来夸夸自己？就是要handle多个推荐人其实也挺累的，不过我觉得worth a try :)</p>
<h2 id="录取过程">3. 录取过程</h2>
<h3 id="状态变化">3.1 状态变化</h3>
<p>说实话录取过程的状态变化有点记不清了，应该是有以下几个状态：</p>
<ul>
<li>In progress: 没啥好说的，2月1号材料递交截止之后就会变成这个</li>
<li>Unqualified: 这应该是你有某项材料不合格，此时应该马上发邮件去问学校到底是哪里不合格，我觉得此时能补救就别放弃了。2月1号材料截止，4月6号出结果，中间的时间都够考好几次托福了</li>
<li>Qualified / Conditionally qualified: 说明你的材料都合格了，此时会分给你两个东西，一个是group，一个是Merit rating(MR)
<ul>
<li>group: group就是把不同背景的人划分到一个组去竞争，举例来说，要交学费的人和不用交学费的人，是不在一起竞争的，比如Uppsala把我分到了<strong>General assessment (tuition fee applicants) (AUAVG)</strong>组，申请人无需关心这个。</li>
<li>Merit rating: 一般以[你的获得的分值/总分值]的形式呈现，不过今年大部分学校都选择了不告诉大家MR了，怕大家压力太大，所以估计以后申请人想关心也关心不了了。</li>
</ul></li>
<li>Admitted / Conditionally admitted: 说明被录取了，恭喜</li>
<li>Deleted: 当你某志愿被录取后，排在该志愿之后的所有志愿都会被deleted，因为你只能录一个学校</li>
<li>Reserved: 你在waiting list上，除非你在wl的前几名，否则希望渺茫</li>
</ul>
<p>在瑞典申请中，其实(conditionally)qualified意味着很多，我们用回上一节中提到过的数据。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">[University]</th>
<th style="text-align: center;">[number of applicants]</th>
<th style="text-align: center;">[1st hand seeker]</th>
<th style="text-align: center;">[admitted]</th>
<th style="text-align: center;">[reserved]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">KTH</td>
<td style="text-align: center;">1041</td>
<td style="text-align: center;">523</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">77</td>
</tr>
<tr class="even">
<td style="text-align: center;">CTH</td>
<td style="text-align: center;">506</td>
<td style="text-align: center;">183</td>
<td style="text-align: center;">33</td>
<td style="text-align: center;">69</td>
</tr>
</tbody>
</table>
<p>在录取过程中，很多的人会由于各种各样的原因被列为unqualified，如果你能变成(conditionally)qualified，那么在大部分项目里，你已经半只脚迈进录取的门槛了。(conditionally)qualified的后续状态只有两种，admitted和reserved，从录取数据中我们可以看到，如果你被KTH列为(conditionally)qualified，那么你的录取率就从之前算出来的6.15%升高到了<span class="math inline">\(64 / (64 + 77) = 45.39\%\)</span>；如果你被CTH列为(conditionally)qualified，那么你的录取率由6.52%升高到了<span class="math inline">\(33 / (33 + 69) = 32.35\%\)</span>。</p>
<h3 id="thelocal.se">3.2 TheLocal.se</h3>
<p><a href="https://www.thelocal.se/">TheLocal.se</a>是一个发布、分享关于瑞典信息的网站(论坛?)，我觉得大家去了瑞典之后应该会用到。其实它对于申请也是很有帮助的，因为每年申请季，这个论坛都会开一个thread供大家讨论，讨论的人来自世界各地的，大部分都很热心，不过没什么中国人。申请瑞典其实是件挺难熬的事，从2月1日等到4月6日是很漫长的，在等待的过程中，如果能有一个地方让申请人一起讨论各自遇到的问题，是很有帮助的。我觉得2019年申请的时候这个论坛应该也会开一个thread供大家讨论。</p>
<p><a href="https://www.thelocal.se/discuss/index.php?showtopic=86908">2017年的thread</a><br/>
<a href="https://www.thelocal.se/discuss/index.php?showtopic=90408">2018年的thread</a></p>
<h2 id="后记">后记</h2>
<p>KTH的CS Master听起来很诱人，但是其实瑞典国内还有很多其他很好的学校，比如乌普萨拉大学，查尔姆斯大学以及林雪平大学，他们的计算机也很强，只是名声在瑞典之外并不如KTH响罢了。我申请的时候跑去问我的推荐人，他就对我说, “Maybe Chalmers is a better choice for you”。下面三条链接中包含了一些对KTH ICT学院的批评，供大家参考，建议认真看：</p>
<p><a href="https://www.quora.com/What-is-your-review-of-Royal-Institute-of-Technology-KTH">What is your review of Royal Institute of Technology (KTH)?</a><br/>
<a href="https://www.quora.com/How-good-is-KTH-Royal-Institute-of-Technology-for-MS-in-Computer-Science">How good is KTH Royal Institute of Technology for MS in Computer Science?</a><br/>
<a href="http://bbs.gter.net/thread-1820938-1-1.html">吐槽一下KTH的ICT学院</a></p>
<p>当然，KTH有一个其他瑞典学校无法比拟的优势，那就是学生平均水平更高，至少中国学生的水平一定是这样的 ;)</p>
<p>拿到KTH ad的几天之后，我收到了美帝某top30的cs录取，因为女朋友也在美国的原因，我决定前往美国。我为了瑞典的申请准备了一年多，到最后却离开了瑞典，心里确实有些舍不得，也许某天我还会回来这里吧，谁知道呢。</p>
<p>希望这篇文章能对大家的申请起到一些帮助吧。</p>
<h2 id="p.s.">P.S.</h2>
<p>这个周末我去了斯德哥尔摩参观了KTH的主校区/KISTA校区以及乌普萨拉大学，KTH主校区很庄严，KISTA很现代，差点把我绕晕；乌普萨拉很大很宁静，绕着乌普萨拉走到走不动了还没走完。去年去过一次斯德哥尔摩考GRE，就是在KISTA考的，与KTH擦肩而过，那时候没想到KTH就在我考试的地方的隔壁，主要考前太紧张考完太崩溃，也就没想这么多。</p>
<p>今天(16 April)还去KISTA旁听了一节课，当时走到KISTA才突然觉得应该去旁听一节课（虽然下午三点的火车回去了），于是就跑到Service Center让小哥帮我把10点到12点的课列出来给我看下，小哥很认真地查了很久，最后在便利贴上给我写了两门适合我上的课(EE/CS类的Master课程)，Electronic System Design和Internetworking。作为一个硬件白痴，当然是选择去听Internetworking了。离开Service Center之前我还顺手买了两件KTH的衣服作为留念。</p>
<p><img alt="note for courses" height="400" src="../imgs/note_for_courses.png"/> <img alt="KTH jacket" height="400" src="../imgs/kth_jacket.png"/> <img alt="KTH hoodie" height="400" src="../imgs/kth_hoodie.png"/></p>
<p><a href="https://www.kth.se/student/kurser/kurs/IK1552?l=en">IK1552 Internetworking</a>这门课来自<a href="https://people.kth.se/~maguire/">Professor Gerald Q. “Chip” Maguire Jr.</a>。我第一眼看到他就知道来对地方了，因为他看着就很厉害，实际上也真的很厉害，人也很和蔼。我到教室的时候就他一个人在那，我问他说我能audit这门课吗，他说这门课没有official audit，不过你可以来听，就是上课的时候你要回答问题。我一开始感觉好吧回答就回答吧，反正也问不到几次，结果后来发现上课的人很少，除我之外一共就7个人，其中有2个中国人，然后我被问到了四五次问题，貌似只答上来两次。幸好来瑞典之后上过CCNA的课程，基本内容都了解，不然就听天书了，因为我在北京的时候根本没上过dedicated circuit、VoIP、SNMP这些东西。Gerald讲课的速度比我平时上的课快一点，跟上是能跟上，就是好几次感觉“这个地方我还可以再思考一下”的时候，却不得不马上接下去听了。反正全程紧张，被问到问题的时候，有时还在理解他的问题是啥意思，不过上过几节之后应该就会适应了。Gerald的课容量不小，也很紧凑（重点体现在没有下课，不过由于太好听了所以下不下课无所谓），人很有趣，提问也非常thought-provoking，Anyway，听完之后简直就想赖在KTH天天蹭课听了 :)</p>
<p>本着写成小学生游记的目标，我决定在最后附上本次visit的<a href="./stockholm-visit.html">照片</a></p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>Reservoir Computing 简介</title><published>Feb 25, 2018</published><updated>2020-03-06T11:20:43Z</updated><link href="http://jujuba.me/posts/reservoir_computing.html"/><id>http://jujuba.me/posts/reservoir_computing.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">Reservoir Computing 简介</h1>
<p class="date">Feb 25, 2018</p>
</header>
<h2 id="总览">0. 总览</h2>
<hr/>
<p>Reservoir Computing， 也叫Echo state network， 被视为是神经网络(Neural Network)的一种拓展框架。一个reservoir computer由以下三个部分组成：</p>
<ul>
<li>输入层(input layer): 可以由一个或多个node组成， 属于前馈神经网络(feed-forward Neural network)的一种.</li>
<li>中间层(middle layer): 由多个node组成， 属于递归神经网络(recurrent Neural network)的一种.</li>
<li>输出层(output layer): 带有权重的加法器(weighted summer).</li>
</ul>
<p><img alt="reservoir_components" src="../imgs/reservoir_components.png" style="height: 300px;"/></p>
<p>前馈神经网络与递归神经网络的差别在于前者只允许信号从输入层向前传到输出层，信号的传递是单向的，它也不存在任何的回路，也就是说任何一层的输出都无法影响这层本身的数据，一般用于模式识别；后者通过引入循环的方法允许信号双向传递。</p>
<p><img alt="reservoir_components" src="../imgs/feedback_and_recurrent.png" style="height: 200px;"/></p>
<p>目前已知reservoir有以下三个关键特性：</p>
<ul>
<li>通常reservoir有很多节点，且节点的连接是稀疏的，故该矩阵是稀疏矩阵</li>
<li>因为节点之间会形成很多循环，故reservoir中的nodes形成的是递归神经网络</li>
<li>各节点会在学习阶段使用一种高效递归的架构使节点的权重不断更新</li>
</ul>
<p>Reservoir computing的一个神奇之处在于，中间层的reservoir矩阵是随机生成的且生成后就保持不变，真正需要训练的只有输出层，这也使它比传统的方法快很多。</p>
<h2 id="运行过程">1. 运行过程</h2>
<hr/>
<p>下面提出一种reservoir computing的示例，该reservoir的输入层有M个节点，中间层有N个节点，输出层有P个节点，reservoir dynamics被定义为：<br/>
<span class="math display">\[\textbf{r}(t + \Delta t) = (1 - \alpha)\textbf{r}(t) + \alpha tanh(\textbf{Ar}(t) + \textbf{W}_{in}\textbf{u}(t) + \xi 1)\]</span></p>
<p>其中各变量意义如下：</p>
<ul>
<li><span class="math inline">\(\alpha\)</span>: leakage rate，主要用来控制reservoir中各节点权重更新的速度</li>
<li><strong>r</strong>: reservoir state vector，记录了reservoir中每个节点的权重信息</li>
<li><strong>A</strong>: reservoir的权重邻接矩阵(weighted adjacency matrix)，通常是一个稀疏矩阵，这里用Erdős–Rényi来生成</li>
<li><span class="math inline">\(\textbf{W}_{in}\)</span>: N行M列的矩阵，主要是用来将M维的输入信号转换为reservoir可接受的形式</li>
<li><strong>u</strong>(t): 输入信号，维度为M</li>
<li><span class="math inline">\(\xi\)</span>: bias，即偏置</li>
</ul>
<p><img alt="reservoir_weight" src="../imgs/reservoir_W_in.png" style="height: 150px;"/></p>
<h3 id="训练">1.1 训练</h3>
<p>前期主要分为两个阶段，初始阶段(Initial period)和训练阶段(Training period)。在初始阶段，一般认为所有信号都是已知的，此时无需记录reservoir中节点的状态。当初始阶段结束训练阶段开始时，需要将每一次计算得到的reservoir状态记录到一个矩阵中。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(trainLen):</a>
<a class="sourceLine" id="cb1-2" title="2">  u <span class="op">=</span> input_signal[t]</a>
<a class="sourceLine" id="cb1-3" title="3">  r <span class="op">=</span> (<span class="dv">1</span> − alpha) ∗ r <span class="op">+</span> alpha ∗ np.tanh(np.dot(A, r) <span class="op">+</span> np.dot(Win, u) <span class="op">+</span> bias) </a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="cf">if</span> t <span class="op">&gt;=</span> initLen:</a>
<a class="sourceLine" id="cb1-5" title="5">    R[:, [t − initLen]] <span class="op">=</span> np.vstack((u, r))[:, <span class="dv">0</span>]</a></code></pre></div>
<p>收集到这些状态以后，就可以训练输出层了，这里使用ridge regression来训练。<br/>
<span class="math display">\[W^*_{out} = \textbf{SR}^T (\textbf{RR}^T + \beta \textbf{I})^{-1}\]</span></p>
<h3 id="测试">1.2 测试</h3>
<p>训练得到<span class="math inline">\(W_{out}\)</span>之后，就可以使用公式<span class="math inline">\(\hat{\textbf{s}} = \textbf{W}_{out}\textbf{r}(t)\)</span>来测试reservoir了。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">S <span class="op">=</span> np.zeros((P, testLen))</a>
<a class="sourceLine" id="cb2-2" title="2">u <span class="op">=</span> input_signal[trainLen]</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(testLen):</a>
<a class="sourceLine" id="cb2-4" title="4">  r <span class="op">=</span> (<span class="dv">1</span> − alpha) ∗ r <span class="op">+</span> alpha ∗ np.tanh(np.dot(A, r) <span class="op">+</span> np.dot(Win, u) <span class="op">+</span> bias) </a>
<a class="sourceLine" id="cb2-5" title="5">  s <span class="op">=</span> np.dot(Wout, np.vstack((u, r)))</a>
<a class="sourceLine" id="cb2-6" title="6">  S[:, t] <span class="op">=</span> s </a>
<a class="sourceLine" id="cb2-7" title="7">  u<span class="op">=</span>s</a></code></pre></div>
<h3 id="评估">1.3 评估</h3>
<p>只需比较reservoir生成的结果与真实的数据即可，一般用RMS(root mean square) error来衡量。</p>
<h2 id="示例">2. 示例</h2>
<p>该reservoir有两种用法，模拟信号与预测信号。</p>
<hr/>
<h3 id="模拟">2.1 模拟</h3>
<p>这里使用以下JSON来配置这个reservoir，从而模拟Lorenz System:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="dt">"input"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="dt">"nodes"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="dt">"functions"</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb3-5" title="5">            <span class="st">"lambda x: lorenz_states[:, 0]"</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb3-6" title="6">            <span class="st">"lambda x: lorenz_states[:, 1]"</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb3-7" title="7">            <span class="st">"lambda x: lorenz_states[:, 2]"</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-9" title="9">        <span class="dt">"length"</span><span class="fu">:</span> <span class="dv">10000</span></a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="dt">"reservoir"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="dt">"start_node"</span><span class="fu">:</span> <span class="dv">400</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="dt">"end_node"</span><span class="fu">:</span> <span class="dv">400</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="dt">"step"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-15" title="15">        <span class="dt">"degree_function"</span><span class="fu">:</span> <span class="st">"lambda x: np.sqrt(x)"</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="dt">"sigma"</span><span class="fu">:</span> <span class="fl">0.5</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-17" title="17">        <span class="dt">"bias"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-18" title="18">        <span class="dt">"leakage_rate"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-19" title="19">        <span class="dt">"regression_parameter"</span><span class="fu">:</span> <span class="dv">1e-07</span></a>
<a class="sourceLine" id="cb3-20" title="20">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb3-21" title="21">    <span class="dt">"output"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb3-22" title="22">        <span class="dt">"nodes"</span><span class="fu">:</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-23" title="23">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb3-24" title="24">    <span class="dt">"training"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb3-25" title="25">        <span class="dt">"init"</span><span class="fu">:</span> <span class="dv">500</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-26" title="26">        <span class="dt">"train"</span><span class="fu">:</span> <span class="dv">4000</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-27" title="27">        <span class="dt">"test"</span><span class="fu">:</span> <span class="dv">1000</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb3-28" title="28">        <span class="dt">"error"</span><span class="fu">:</span> <span class="dv">500</span></a>
<a class="sourceLine" id="cb3-29" title="29">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb3-30" title="30"><span class="fu">}</span></a></code></pre></div>
<p>我们将Lorenz System的三个信号作为input signal，并在训练完成之后移除该signal，而将该reservoir产生的值作为input signal再输入reservoir。从图中可以看到，该reservoir良好地模拟了Lorenz System。</p>
<p><img alt="lorenz_simulation" src="../imgs/Lorenz_simulation.png" style="height: 500px;"/></p>
<h3 id="预测">2.2 预测</h3>
<p>这里使用以下JSON来配置这个reservoir，从而预测Lorenz System:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="dt">"input"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="dt">"nodes"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="dt">"functions"</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb4-5" title="5">            <span class="st">"lambda x: lorenz_states[:, 2]"</span></a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="dt">"length"</span><span class="fu">:</span> <span class="dv">10000</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="dt">"reservoir"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="dt">"start_node"</span><span class="fu">:</span> <span class="dv">400</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="dt">"end_node"</span><span class="fu">:</span> <span class="dv">400</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-12" title="12">        <span class="dt">"step"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="dt">"degree_function"</span><span class="fu">:</span> <span class="st">"lambda x: np.sqrt(x)"</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-14" title="14">        <span class="dt">"sigma"</span><span class="fu">:</span> <span class="fl">0.5</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="dt">"bias"</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-16" title="16">        <span class="dt">"leakage_rate"</span><span class="fu">:</span> <span class="fl">0.5</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-17" title="17">        <span class="dt">"regression_parameter"</span><span class="fu">:</span> <span class="dv">1e-8</span></a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="dt">"output"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb4-20" title="20">        <span class="dt">"nodes"</span><span class="fu">:</span> <span class="dv">2</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-21" title="21">        <span class="dt">"functions"</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb4-22" title="22">            <span class="st">"lambda x: lorenz_states[:, 0]"</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb4-23" title="23">            <span class="st">"lambda x: lorenz_states[:, 1]"</span></a>
<a class="sourceLine" id="cb4-24" title="24">        <span class="ot">]</span></a>
<a class="sourceLine" id="cb4-25" title="25">    <span class="fu">},</span></a>
<a class="sourceLine" id="cb4-26" title="26">    <span class="dt">"training"</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb4-27" title="27">        <span class="dt">"init"</span><span class="fu">:</span> <span class="dv">500</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-28" title="28">        <span class="dt">"train"</span><span class="fu">:</span> <span class="dv">4000</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-29" title="29">        <span class="dt">"test"</span><span class="fu">:</span> <span class="dv">2000</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb4-30" title="30">        <span class="dt">"error"</span><span class="fu">:</span> <span class="dv">500</span></a>
<a class="sourceLine" id="cb4-31" title="31">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb4-32" title="32"><span class="fu">}</span></a></code></pre></div>
<p>以x作为input signal, y &amp; z作为teacher signal来训练，训练后便可以使用x来预测y &amp; z</p>
<p><img src="../imgs/Lorenz_x2yz.png" style="height: 600px;"/></p>
<p>以y作为input signal, x &amp; z作为teacher signal来训练，训练后便可以使用y来预测x &amp; z</p>
<p><img src="../imgs/Lorenz_y2xz.png" style="height: 600px;"/></p>
<p>以z作为input signal, x &amp; y作为teacher signal来训练，训练后无法使用y来预测x &amp; z。原因在于在只知道z的情况下，我们无法得知x与y的符号，从而造成了non-observability。</p>
<p><img src="../imgs/Lorenz_z2xy.png" style="height: 600px;"/></p>
<p><strong>注:</strong> 本文代码可以在<a href="https://github.com/jiahao42/Reservoir">此处</a>下载</p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>使用Ruby开发Shadowsocks</title><published>Mar 21, 2018</published><updated>2020-03-06T11:20:43Z</updated><link href="http://jujuba.me/posts/shadowsocks_in_ruby.html"/><id>http://jujuba.me/posts/shadowsocks_in_ruby.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">使用Ruby开发Shadowsocks</h1>
<p class="date">Mar 21, 2018</p>
</header>
<p><img alt="shawshank" src="../imgs/shawshank_the_wall.jpg" style="height: 250px;"/></p>
<blockquote>
<p>You believe whatever you want Floyd, but I am telling you these walls are funny. First you hate ’em, then you get used to ’em. Enough time passes, gets so you depend on them. That’s institutionalized. They send you here for life, that’s exactly what they take. The part that counts, anyway.</p>
</blockquote>
<p>Scope: Shadowsocks的原理, Shadowsocks的简易实现</p>
<hr/>
<ul>
<li><ol start="0" type="1">
<li><a href="#nonsense">废话</a></li>
</ol></li>
<li><ol type="1">
<li><a href="#How">原理</a></li>
</ol></li>
<li><ol start="2" type="1">
<li><a href="#implement">简易实现</a></li>
</ol>
<ul>
<li>2.1 <a href="#socks">SOCKS客户端与服务器的连接</a></li>
<li>2.2 <a href="#local_server">ss_local与ss_server之间的通信</a></li>
<li>2.3 <a href="#running">ss的调试及运行</a></li>
<li>2.4 <a href="#multi_thread">多线程</a></li>
<li>2.5 <a href="#cryptography">加密相关</a> // TODO</li>
<li>2.6 <a href="#optimization">优化</a> // TODO</li>
</ul></li>
</ul>
<p><a name="nonsense"></a></p>
<h2 id="废话">0. 废话</h2>
<p>眼看本科生涯就要结束了，觉得自己还有很多想做的事都没有做，其中两件就是学一下Ruby和写一个代理。个人认为学会了Python和Racket之后，再学Ruby在语言层面上并不会有什么太大的收获，不过bonus就是可以顺便学学Ruby on Rails，一个非常不错的Web框架。我想学Ruby纯粹是因为Ruby的名字好听加上logo好看，再加上看了官方的教程<a href="https://www.ruby-lang.org/en/documentation/quickstart/">Ruby in Twenty Minutes</a>之后，觉得Ruby颇有些loosely-knit的味道，适合写代码时放飞自我。对于墙的问题，我就不想再对此评论什么了，作为一个独立的个体，我会贡献出我的价值，以此来表达我的观点。希望6月回国之后可以用上自己写的代理 :)</p>
<p><a name="How"></a></p>
<h2 id="原理">1. 原理</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E">GFW</a>的主要手段有DNS污染和TCP协议关键字审查，Shadowsocks的应对方式也很简单，找一台不受GFW所限制的机器作为中介。主要流程如下：</p>
<ul>
<li><ol type="1">
<li>ss本地客户端会将网络请求加密后转发到中介机器</li>
</ol></li>
<li><ol start="2" type="1">
<li>中介机器解密请求并向真正的目标服务器发起请求</li>
</ol></li>
<li><ol start="3" type="1">
<li>中介机器获得数据后又将数据加密并发回ss本地客户端</li>
</ol></li>
<li><ol start="4" type="1">
<li>ss本地客户端对数据进行解密</li>
</ol></li>
</ul>
<figure>
<img alt="shadowsocks_architecture" src="../imgs/ss_arch.dot.png"/><figcaption>shadowsocks_architecture</figcaption>
</figure>
<p>对于DNS污染，中介机器在墙外，不受墙内的DNS污染影响；对于TCP协议关键字审查，ss_local与ss_server之间的流量是加密的，所以墙也无法审查。当然这两个都是老手段了，墙还有很多其他的招式，比如开某会期间，直接实行封端口的策略，导致一时间好多人将443端口作为ss_server的端口来使用。封端口策略是一种非常愚蠢又极端的手段，设想所有服务器只被允许开放特定端口，那么服务器的服务就只能被部署在这几个特定端口上，这下好了，黑客想拿你的站直接连扫端口这一步也省了 :）</p>
<p><a name="implement"></a></p>
<h2 id="简易实现">2. 简易实现</h2>
<p>本实现使用以下配置：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">"server"</span><span class="fu">:</span> <span class="st">"127.0.0.1"</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">"server_port"</span><span class="fu">:</span> <span class="dv">5246</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="dt">"local_port"</span><span class="fu">:</span> <span class="dv">1080</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">"encrypt-method"</span><span class="fu">:</span> <span class="st">"aes-256-gcm"</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="fu">}</span></a></code></pre></div>
<p><a name="socks"></a></p>
<h3 id="socks客户端与服务器的连接">2.1 SOCKS客户端与服务器的连接</h3>
<p>Shadowsocks使用的是SOCKS5代理协议，其具体细节在<a href="https://tools.ietf.org/html/rfc1928">RFC1928</a>中被定义。SOCKS5协议中的client可以看作是计算机发出的网络请求，server就是ss_local。二者之间首先要进行握手以及认证，从而建立连接，具体过程如下图所示：</p>
<p><img alt="shadowsocks_socks5_details" src="../imgs/ss_socks5.dot.png" style="height: 500px;"/></p>
<p>上图中的stage_0 - stage_2属于建立SOCKS5握手阶段，此时计算机会默认向1080端口发出请求“\x05\x01\x00”进行SOCKS5连接的消息，该消息由三部分组成：</p>
<ul>
<li>“\x05”: SOCKS5版本 = 0x05，占1字节</li>
<li>“\x01”: Method identifier的数量(0x01 - 0xff)，此处\x01说明该客户端只支持一种连接方式，占1字节</li>
<li>“\x00”: Method identifiers，此处\x00就是该客户端只支持的这一种方式的identifier，即无需认证的连接方式。此处每个Method identifier占一字节，最多占0xff字节</li>
</ul>
<p>监听在1080端口的ss_local，即SOCKS5服务器收到该消息后会回复“\x05\x00”，该消息由两部分组成：</p>
<ul>
<li>“\x05”: SOCKS5版本 = 0x05，占1字节</li>
<li>“\x00”: Method identifier，此处表示选择identifier为\x00的方式，即无需认证的连接方式，占1字节</li>
</ul>
<p>具体代码如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> <span class="dt">Local</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">def</span> initialize()</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="ot">@utils</span> = <span class="dt">Utils</span>.new</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="ot">@config</span> = <span class="ot">@utils</span>.config</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="ot">@local_port</span> = <span class="ot">@config</span>[<span class="st">'local_port'</span>]</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="ot">@local</span> = <span class="dt">TCPServer</span>.new(<span class="ot">@local_port</span>)    <span class="co"># Listen</span></a>
<a class="sourceLine" id="cb2-7" title="7">    ...</a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="kw">def</span> run()</a>
<a class="sourceLine" id="cb2-10" title="10">    loop {                           <span class="co"># Servers run forever</span></a>
<a class="sourceLine" id="cb2-11" title="11">      <span class="ot">@client</span> = <span class="ot">@local</span>.accept</a>
<a class="sourceLine" id="cb2-12" title="12">      <span class="co"># Receive</span></a>
<a class="sourceLine" id="cb2-13" title="13">      <span class="co"># +----+----------+----------+</span></a>
<a class="sourceLine" id="cb2-14" title="14">      <span class="co"># |VER | NMETHODS | METHODS  |</span></a>
<a class="sourceLine" id="cb2-15" title="15">      <span class="co"># +----+----------+----------+</span></a>
<a class="sourceLine" id="cb2-16" title="16">      <span class="co"># | 1  |    1     | 1 to 255 |</span></a>
<a class="sourceLine" id="cb2-17" title="17">      <span class="co"># +----+----------+----------+</span></a>
<a class="sourceLine" id="cb2-18" title="18">      ver = <span class="ot">@client</span>.read(<span class="dv">1</span>) <span class="co"># VER</span></a>
<a class="sourceLine" id="cb2-19" title="19">      <span class="kw">if</span> ver != <span class="st">"\x05"</span></a>
<a class="sourceLine" id="cb2-20" title="20">        <span class="ot">@client</span>.close</a>
<a class="sourceLine" id="cb2-21" title="21">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb2-22" title="22">      n_methods = <span class="ot">@client</span>.read(<span class="dv">1</span>) <span class="co"># NMETHODS</span></a>
<a class="sourceLine" id="cb2-23" title="23">      methods = <span class="ot">@client</span>.read(n_methods.ord) <span class="co"># METHODS</span></a>
<a class="sourceLine" id="cb2-24" title="24">      <span class="co"># Send</span></a>
<a class="sourceLine" id="cb2-25" title="25">      <span class="co"># +----+--------+</span></a>
<a class="sourceLine" id="cb2-26" title="26">      <span class="co"># |VER | METHOD |</span></a>
<a class="sourceLine" id="cb2-27" title="27">      <span class="co"># +----+--------+</span></a>
<a class="sourceLine" id="cb2-28" title="28">      <span class="co"># | 1  |   1    |</span></a>
<a class="sourceLine" id="cb2-29" title="29">      <span class="co"># +----+--------+</span></a>
<a class="sourceLine" id="cb2-30" title="30">      data = <span class="st">"\x05\x00"</span></a>
<a class="sourceLine" id="cb2-31" title="31">      <span class="ot">@client</span>.write data</a>
<a class="sourceLine" id="cb2-32" title="32">      ...</a>
<a class="sourceLine" id="cb2-33" title="33">    }</a></code></pre></div>
<p>握手阶段结束后是stage_2 - stage_4，此时计算机会向1080端口发出请求细节，此处我们使用“\x05\x01\x00\x03\x0e + b’www.google.com’ + \x01\xbb”，该请求由以下几部分组成：</p>
<ul>
<li>“\x05”: SOCKS5版本 = 0x05，占1字节</li>
<li>“\x01”: 该请求希望执行的命令，\x01代表Connect，占1字节</li>
<li>“\x00”: Reserved，占1字节</li>
<li>“\x03”: Address type，地址类型，共有三种，此处\x03代表域名，占1字节</li>
<li>“\x0e”: 域名长度，此处域名www.google.com的长度为\x0e，占1字节</li>
<li>“b’www.google.com’”: 需要访问的域名，域名的长度由前一字节指定，最多占0xff字节
<ul>
<li>注：此处可以看出域名的长度的限制，其长度不能超过0xff个字符，这一点可以在Wikipedia上求证，[<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。]</a></li>
</ul></li>
<li>“\x01\xbb”: 需要访问的端口，Google使用的是https，故使用443端口，占2字节</li>
</ul>
<p>监听在1080端口的ss_local，即SOCKS5服务器收到该消息后需要做两件事：<br/>
1. 将需要访问的地址与端口加密后发送到ss_server<br/>
2. 回复“\x05\x00\x00\x01\x00\x00\x00\x00\x00\x00”到计算机，该消息由以下几部分组成：</p>
<ul>
<li>“\x05”: SOCKS5版本 = 0x05，占1字节</li>
<li>“\x00”: Reply，此处\x00代表success，占1字节</li>
<li>“\x00”: Reserved，占1字节</li>
<li>“\x01”: Address type，地址类型，共有三种，此处\x01代表ipv4地址，占1字节</li>
<li>“\x00\x00\x00\x00”: server bound address，该地址只用在服务器主动对客户端发起连接的情况下，如FTP，此处并不适用，直接使用0x00填充，占4字节</li>
<li>“\x00\x00”: server bound port，此处并不适用，使用0x00填充，占2字节</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> <span class="dt">Local</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">def</span> initialize()</a>
<a class="sourceLine" id="cb3-3" title="3">    ...</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="ot">@utils</span>.init_cipher(<span class="ot">@config</span>[<span class="st">'encrypt-method'</span>])</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="ot">@server_addr</span> = <span class="ot">@config</span>[<span class="st">'server'</span>]</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="ot">@server_port</span> = <span class="ot">@config</span>[<span class="st">'server_port'</span>]</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="ot">@server</span> = <span class="dt">TCPSocket</span>.open(<span class="ot">@server_addr</span>, <span class="ot">@server_port</span>)</a>
<a class="sourceLine" id="cb3-8" title="8">    ...</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="kw">def</span> run()</a>
<a class="sourceLine" id="cb3-11" title="11">    loop {</a>
<a class="sourceLine" id="cb3-12" title="12">      ...</a>
<a class="sourceLine" id="cb3-13" title="13">      <span class="co"># Receive</span></a>
<a class="sourceLine" id="cb3-14" title="14">      <span class="co"># +----+-----+-------+------+----------+----------+</span></a>
<a class="sourceLine" id="cb3-15" title="15">      <span class="co"># |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></a>
<a class="sourceLine" id="cb3-16" title="16">      <span class="co"># +----+-----+-------+------+----------+----------+</span></a>
<a class="sourceLine" id="cb3-17" title="17">      <span class="co"># | 1  |  1  | X'00' |  1   | Variable |    2     |</span></a>
<a class="sourceLine" id="cb3-18" title="18">      <span class="co"># +----+-----+-------+------+----------+----------+</span></a>
<a class="sourceLine" id="cb3-19" title="19">      ver = <span class="ot">@client</span>.read(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-20" title="20">      <span class="kw">if</span> ver != <span class="st">"\x05"</span></a>
<a class="sourceLine" id="cb3-21" title="21">        <span class="ot">@client</span>.close</a>
<a class="sourceLine" id="cb3-22" title="22">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb3-23" title="23">      <span class="co"># o  CMD</span></a>
<a class="sourceLine" id="cb3-24" title="24">      <span class="co"># o  CONNECT X'01'</span></a>
<a class="sourceLine" id="cb3-25" title="25">      <span class="co"># o  BIND X'02'</span></a>
<a class="sourceLine" id="cb3-26" title="26">      <span class="co"># o  UDP ASSOCIATE X'03'</span></a>
<a class="sourceLine" id="cb3-27" title="27">      cmd = <span class="ot">@client</span>.read(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-28" title="28">      rsv = <span class="ot">@client</span>.read(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-29" title="29">      <span class="co"># o  ATYP   address type of following address</span></a>
<a class="sourceLine" id="cb3-30" title="30">      <span class="co"># o  IP V4 address: X'01' - 4 bytes</span></a>
<a class="sourceLine" id="cb3-31" title="31">      <span class="co"># o  DOMAINNAME: X'03' - the first byte stands for length</span></a>
<a class="sourceLine" id="cb3-32" title="32">      <span class="co"># o  IP V6 address: X'04' - 16 bytes</span></a>
<a class="sourceLine" id="cb3-33" title="33">      atyp = <span class="ot">@client</span>.read(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-34" title="34">      msg = atyp</a>
<a class="sourceLine" id="cb3-35" title="35">      <span class="kw">if</span> atyp == <span class="st">"\x01"</span></a>
<a class="sourceLine" id="cb3-36" title="36">        dst_addr = <span class="ot">@client</span>.read(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb3-37" title="37">        msg += dst_addr</a>
<a class="sourceLine" id="cb3-38" title="38">      <span class="kw">elsif</span> atyp == <span class="st">"\x03"</span></a>
<a class="sourceLine" id="cb3-39" title="39">        len = <span class="ot">@client</span>.read(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-40" title="40">        dst_addr = <span class="ot">@client</span>.read(len.ord)</a>
<a class="sourceLine" id="cb3-41" title="41">        msg += len + dst_addr</a>
<a class="sourceLine" id="cb3-42" title="42">      <span class="kw">elsif</span> atyp == <span class="st">"\x04"</span></a>
<a class="sourceLine" id="cb3-43" title="43">        dst_addr = <span class="ot">@client</span>.read(<span class="dv">16</span>)</a>
<a class="sourceLine" id="cb3-44" title="44">        msg += dst_addr</a>
<a class="sourceLine" id="cb3-45" title="45">      <span class="kw">end</span></a>
<a class="sourceLine" id="cb3-46" title="46">      dst_port = <span class="ot">@client</span>.read(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb3-47" title="47">      msg += dst_port</a>
<a class="sourceLine" id="cb3-48" title="48">      <span class="ot">@server</span>.write <span class="ot">@utils</span>.encrypt(msg)</a>
<a class="sourceLine" id="cb3-49" title="49">      <span class="co"># Send</span></a>
<a class="sourceLine" id="cb3-50" title="50">      <span class="co"># +----+-----+-------+------+----------+----------+</span></a>
<a class="sourceLine" id="cb3-51" title="51">      <span class="co"># |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span></a>
<a class="sourceLine" id="cb3-52" title="52">      <span class="co"># +----+-----+-------+------+----------+----------+</span></a>
<a class="sourceLine" id="cb3-53" title="53">      <span class="co"># | 1  |  1  | X'00' |  1   | Variable |    2     |</span></a>
<a class="sourceLine" id="cb3-54" title="54">      <span class="co"># +----+-----+-------+------+----------+----------+</span></a>
<a class="sourceLine" id="cb3-55" title="55">      data = <span class="st">"\x05"</span> + <span class="st">"\x00"</span> + <span class="st">"\x00"</span> + <span class="st">"\x01"</span> + <span class="st">"\x00\x00\x00\x00"</span> + <span class="st">"\x00\x00"</span></a>
<a class="sourceLine" id="cb3-56" title="56">      <span class="ot">@client</span>.write data</a>
<a class="sourceLine" id="cb3-57" title="57">      ...</a>
<a class="sourceLine" id="cb3-58" title="58">    }</a></code></pre></div>
<p>至此，SOCKS5连接已经建立完毕。</p>
<p><a name="local_server"></a></p>
<h3 id="ss_local与ss_server之间的通信">2.2 ss_local与ss_server之间的通信</h3>
<p>SOCKS5连接建立完毕之后，剩下的就只有ss_local与ss_server之间的TCP转发及加解密问题了。</p>
<p>ss_local连接ss_server的过程非常简单：从config.json里读出server的地址及端口，直接一个TCP连接连过去就ok了。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="dt">Local</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">def</span> initialize()</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="ot">@server_addr</span> = <span class="ot">@config</span>[<span class="st">'server'</span>]</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="ot">@server_port</span> = <span class="ot">@config</span>[<span class="st">'server_port'</span>]</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="ot">@server</span> = <span class="dt">TCPSocket</span>.open(<span class="ot">@server_addr</span>, <span class="ot">@server_port</span>)</a>
<a class="sourceLine" id="cb4-6" title="6">    ...</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="kw">def</span> run()</a>
<a class="sourceLine" id="cb4-9" title="9">    loop {</a>
<a class="sourceLine" id="cb4-10" title="10">      ...</a>
<a class="sourceLine" id="cb4-11" title="11">      handle_tcp(<span class="ot">@client</span>, <span class="ot">@server</span>)</a>
<a class="sourceLine" id="cb4-12" title="12">    }</a>
<a class="sourceLine" id="cb4-13" title="13">  ...</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">end</span></a></code></pre></div>
<p>之前说到过ss_local<strong>将需要访问的地址与端口加密后发送到ss_server</strong>，同样的，ss_server收到地址和域名后，直接一个TCP连接连过去。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> <span class="dt">Server</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="kw">def</span> run()</a>
<a class="sourceLine" id="cb5-3" title="3">    ...</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="ot">@remote</span> = <span class="dt">TCPSocket</span>.open(target_addr, target_port)</a>
<a class="sourceLine" id="cb5-5" title="5">    handle_tcp(<span class="ot">@client</span>, <span class="ot">@server</span>)</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">end</span></a></code></pre></div>
<p>至此client、ss_local、ss_server三者已经连接在了一起。目前的问题在于，ss_local如何将收到的requests转发给ss_server？ss_server又如何将收到的responses转发给ss_local？我们只要实现一个TCP转发函数<code>handle_tcp(source, destination)</code>即可。注意ss_local与ss_server的<code>handle_tcp</code>函数的实现都是相同的，因为它们需要做的事情是一样的，即将收到的TCP数据转发到另一端。该函数的核心在于判断何时该从socket中读数据，何时从socket中写数据，这个任务可以通过调用<a href="http://ruby-doc.org/core-2.0.0/IO.html#method-c-select">select函数</a>来完成，select函数会返回ready for reading/writing的sockets。如果某一socket is ready for reading了，那就读取这个socket中的数据并写入到另一个socket中，这样一来就实现了TCP的转发。当然，在读／写的时候，不能忘记对流量进行解密／加密，否则会被墙检查到流量中的关键字，轻则重置连接，重则封锁墙外服务器的ip。</p>
<blockquote>
<p>select(read_array [, write_array [, error_array [, timeout]]]) → array or nil<br/>
Calls select(2) system call. It monitors given arrays of IO objects, waits one or more of IO objects ready for reading, are ready for writing, and have pending exceptions respectably, and returns an array that contains arrays of those IO objects. It will return nil if optional timeout value is given and no IO object is ready in timeout seconds.</p>
</blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">$blockSize</span> = <span class="dv">1024</span> * <span class="dv">100</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">def</span> handle_tcp(src, dest)</a>
<a class="sourceLine" id="cb6-3" title="3">  loop {</a>
<a class="sourceLine" id="cb6-4" title="4">    ready = select([src, dest], <span class="dv">nil</span>, <span class="dv">nil</span>)</a>
<a class="sourceLine" id="cb6-5" title="5">    puts ready[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">if</span> ready[<span class="dv">0</span>].include? src</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="co"># src -&gt; dest</span></a>
<a class="sourceLine" id="cb6-8" title="8">        data = src.recv(<span class="dt">$blockSize</span>)</a>
<a class="sourceLine" id="cb6-9" title="9">        <span class="kw">if</span> data.empty?</a>
<a class="sourceLine" id="cb6-10" title="10">            puts <span class="st">"src end closed connection"</span></a>
<a class="sourceLine" id="cb6-11" title="11">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb6-12" title="12">        <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-13" title="13">        data = <span class="ot">@utils</span>.encrypt(data)</a>
<a class="sourceLine" id="cb6-14" title="14">        dest.write(data)</a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="kw">if</span> ready[<span class="dv">0</span>].include? dest</a>
<a class="sourceLine" id="cb6-17" title="17">        <span class="co"># dest -&gt; src</span></a>
<a class="sourceLine" id="cb6-18" title="18">        data = dest.recv(<span class="dt">$blockSize</span>)</a>
<a class="sourceLine" id="cb6-19" title="19">        <span class="kw">if</span> data.empty?</a>
<a class="sourceLine" id="cb6-20" title="20">            puts <span class="st">"dest end closed connection"</span></a>
<a class="sourceLine" id="cb6-21" title="21">            <span class="kw">break</span></a>
<a class="sourceLine" id="cb6-22" title="22">        <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-23" title="23">        data = <span class="ot">@utils</span>.decrypt(data)</a>
<a class="sourceLine" id="cb6-24" title="24">        src.write(data)</a>
<a class="sourceLine" id="cb6-25" title="25">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-26" title="26">  }</a>
<a class="sourceLine" id="cb6-27" title="27"><span class="kw">end</span></a></code></pre></div>
<p><a name="running"></a></p>
<h3 id="ss的调试及运行">2.3 ss的调试及运行</h3>
<p>在调试程序的过程中，需要一个SOCKS5客户端，我们可以自己写一个客户端，向ss_local端口（1080）发送指定消息，也可以将本机的代理设置为SOCKS5。macOS下可以进入<br/>
<strong>System Preference -&gt; Network -&gt; Advanced -&gt; Proxies -&gt; SOCKS Proxy</strong>进行相应更改。</p>
<p><img alt="macos socks5" src="../imgs/macOS_socks5.png" style="height: 400px;"/></p>
<p>调试完成之后，就可以投入使用了。在本机上运行local.rb，并将server.rb放到墙外的服务器上运行，打开本机的SOCKS代理就可以使用浏览器访问不存在的网站了，也可以使用命令行进行测试<br/>
<code>curl --socks5-hostname 127.0.0.1:1080 https://google.com/</code><br/>
记得把config.json中的ip地址改为墙外服务器的地址并确保端口信息正确，good luck!</p>
<p><a name="multi_thread"></a></p>
<h3 id="多线程">2.4 多线程</h3>
<p>用单线程的版本的Shadowsocks访问Twitter，却发现所有图片都无法加载…</p>
<p><img alt="single_thread_twitter" src="../imgs/single_thread_twitter.png" style="height: 500px;"/></p>
<h4 id="为何需要多线程">2.4.1 为何需要多线程</h4>
<p>client、ss_local、ss_server三者是通过socket来通信的，而socket往往由一个三元组来表示<strong>[协议，地址，端口]</strong>。显然，一个线程一次只能访问一个socket，一个socket只能表示一个三元组，而大多数网站资源的来源都不止一个（如网站会使用CDN加速），所以单线程的ss就只能获取到网站的部分资源。这也是上图中Twitter图片无法加载的原因：Twitter的文字来自twitter.com，而图片却来自pbs.twimg.com，ss唯一的线程一直在访问twitter.com，当然就无法获取图片资源了。单线程还会导致软件效率低下，因为CPU资源会被缓慢的网络传输及I/O所浪费。</p>
<h4 id="改写为多线程">2.4.2 改写为多线程</h4>
<p>多线程的改写在Ruby中较为简单，直接用<code>Thread.new</code>或者<code>Thread.start</code>创建线程即可，当CPU空闲时改线程会自动运行，无需手动启动线程。新建线程时会用到有趣的Ruby block，要运行的线程代码会被作为block传给线程。</p>
<p>ss_local可改为：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">Local</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="kw">def</span> initialize()</a>
<a class="sourceLine" id="cb7-3" title="3">    ...</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="ot">@port</span> = <span class="ot">@config</span>[<span class="st">'local_port'</span>]</a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="ot">@local</span> = <span class="dt">TCPServer</span>.new(<span class="ot">@port</span>)    <span class="co"># Listen</span></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="kw">def</span> run()</a>
<a class="sourceLine" id="cb7-9" title="9">    loop {</a>
<a class="sourceLine" id="cb7-10" title="10">      <span class="dt">Thread</span>.start (<span class="ot">@local</span>.accept) {|client| thread_run(client)} <span class="co"># Ruby block</span></a>
<a class="sourceLine" id="cb7-11" title="11">    }</a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14">  <span class="kw">def</span> thread_run(client)</a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="co"># SOCKS5 handshake</span></a>
<a class="sourceLine" id="cb7-16" title="16">    <span class="co"># SOCKS5 request/reply</span></a>
<a class="sourceLine" id="cb7-17" title="17">    handle_tcp(client, server)</a>
<a class="sourceLine" id="cb7-18" title="18">    <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb7-19" title="19">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb7-20" title="20">  ...</a>
<a class="sourceLine" id="cb7-21" title="21"><span class="kw">end</span></a></code></pre></div>
<p>类似的，ss_server可改为：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span> <span class="dt">Server</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="kw">def</span> initialize()</a>
<a class="sourceLine" id="cb8-3" title="3">    ...</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="ot">@server_port</span> = <span class="ot">@config</span>[<span class="st">'server_port'</span>]</a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="ot">@server</span> = <span class="dt">TCPServer</span>.new(<span class="ot">@server_port</span>)</a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb8-7" title="7">  </a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="kw">def</span> run() </a>
<a class="sourceLine" id="cb8-9" title="9">    loop {</a>
<a class="sourceLine" id="cb8-10" title="10">      <span class="dt">Thread</span>.start (<span class="ot">@server</span>.accept) {|local| thread_run(local)} <span class="co"># Ruby block</span></a>
<a class="sourceLine" id="cb8-11" title="11">    }</a>
<a class="sourceLine" id="cb8-12" title="12">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14">  <span class="kw">def</span> thread_run(client)</a>
<a class="sourceLine" id="cb8-15" title="15">    ...</a>
<a class="sourceLine" id="cb8-16" title="16">    remote = <span class="dt">TCPSocket</span>.open(target_addr, target_port)</a>
<a class="sourceLine" id="cb8-17" title="17">    handle_tcp(local, remote)</a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="kw">break</span>;</a>
<a class="sourceLine" id="cb8-19" title="19">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb8-20" title="20">  ...</a>
<a class="sourceLine" id="cb8-21" title="21"><span class="kw">end</span></a></code></pre></div>
<p><a name="cryptography"></a></p>
<h3 id="加密相关">2.5 加密相关</h3>
<p>// TODO</p>
<p><a name="optimization"></a></p>
<h3 id="优化">2.6 优化</h3>
<p>// TODO</p>
<hr/>
<p>本文源代码可在<a href="https://github.com/jiahao42/Shadowsocks-in-Ruby">此处</a>下载</p>
<p><img alt="shawshank italian" src="../imgs/shawshank_italian.jpg" style="height: 250px;"/></p>
<blockquote>
<p>I have no idea to this day what those two Italian ladies were singing about. Truth is, I don’t want to know. Some things are better left unsaid. I’d like to think they were singing about something so beautiful, it can’t expressed in words, and it makes your heart ache because of it. I tell you, those voices soared higher and farther than anybody in a grey place dares to dream. It was as if some beautiful bird had flapped into our drab little cage and made these walls dissolve away, and for the briefest of moments, every last man in Shawshank felt free.</p>
</blockquote>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>SICP笔记 - 抽象的艺术</title><published>Aug 24, 2018</published><updated>2020-03-06T11:20:43Z</updated><link href="http://jujuba.me/posts/sicp-art-of-abstraction.html"/><id>http://jujuba.me/posts/sicp-art-of-abstraction.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">SICP笔记 - 抽象的艺术</h1>
<p class="date">Aug 24, 2018</p>
</header>
<p><img alt="sicp-cover" src="../imgs/sicp-cover-2.png" style="height:250px;"/></p>
<h2 id="overview">0. Overview</h2>
<p>记得大二学C++的时候，老师对我们说面向对象最重要的就三点，抽象、继承与封装。但其实抽象却不是面向对象编程中特有的概念，抽象是编程世界最重要的概念之一，因为编程的过程其实就是使用编程语言描述现实世界的过程，而在这个过程中，最重要的过程之一就是对现实世界进行抽象，将其变成一个个抽象的模型。</p>
<h2 id="抽象">1. 抽象</h2>
<p>SICP的第一章使用了几个例子来描述了代码的抽象过程。</p>
<p>一开始我们的需求很简单，就是求<code>[a, b]</code>区间上所有整数的和，于是有了以下函数：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" title="1">(define (sum-integers a b)</a>
<a class="sourceLine" id="cb1-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-4" title="4">    (<span class="op">+</span> a </a>
<a class="sourceLine" id="cb1-5" title="5">      (sum-integers (<span class="op">+</span> a <span class="dv">1</span>) b))))</a></code></pre></div>
<p>过一会我们又有了新的需求，求<code>[a, b]</code>区间上所有整数的平方和，于是又有了以下函数：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb2-1" title="1">(define (sum-squares a b)</a>
<a class="sourceLine" id="cb2-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-4" title="4">    (<span class="op">+</span> (<span class="op">*</span> a a)</a>
<a class="sourceLine" id="cb2-5" title="5">      (sum-squares (<span class="op">+</span> a <span class="dv">1</span>) b))))</a></code></pre></div>
<p>接下来我们还会有更多类似的需求，比如求<code>[a, b]</code>区间上的立方和，比如我们要计算如下序列的值（该序列会缓慢地向<span class="math inline">\(\pi /8\)</span>收敛）：</p>
<p><span class="math display">\[
\frac{1}{1 * 3} + \frac{1}{5 * 7} + \frac{1}{9 * 11} + ...
\]</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb3-1" title="1">(define (pi-sum a b)</a>
<a class="sourceLine" id="cb3-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-4" title="4">    (<span class="op">+</span> (<span class="op">/</span> <span class="fl">1.0</span> (<span class="op">*</span> a (<span class="op">+</span> a <span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb3-5" title="5">      (pi-sum (<span class="op">+</span> a <span class="dv">4</span>) b))))</a></code></pre></div>
<p>仔细观察可以发现，上面的三个函数都满足同一种模式，我们可以从中抽象出一个模板函数：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb4-1" title="1">(define (&lt;name&gt; a b)</a>
<a class="sourceLine" id="cb4-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-4" title="4">    (<span class="op">+</span> (&lt;term&gt; a)</a>
<a class="sourceLine" id="cb4-5" title="5">      (&lt;name&gt; (&lt;next&gt; a) b))))</a></code></pre></div>
<p>实际上，这个抽象出来的模板函数，就是数学家们在很久之前发明出来的<code>sigma notation</code>，也就是：</p>
<p><span class="math display">\[
\sum_{n = a}^{b} f(n) = f(a) + ... + f(b)
\]</span></p>
<p>注意在上面的代码中，我们缺少<code>term</code>以及<code>next</code>的定义，它们都是函数，分别代表要对当前数字要进行的操作，与获取下一个数字的方法。这里我们可以将这两个函数作为参数传入，这也是Lisp的优雅之处。下面是一个符合Lisp语法要求的模板：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb5-1" title="1">(define (sum term a next b)</a>
<a class="sourceLine" id="cb5-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-4" title="4">    (<span class="op">+</span> (term a)</a>
<a class="sourceLine" id="cb5-5" title="5">      (sum term (next a) next b))))</a></code></pre></div>
<p>这样一来，我们就可以将我们之前的三个函数分别使用该模板来改写：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb6-1" title="1">(define (sum-integers a b)</a>
<a class="sourceLine" id="cb6-2" title="2">  (sum </a>
<a class="sourceLine" id="cb6-3" title="3">    (<span class="kw">lambda</span> (x) x) </a>
<a class="sourceLine" id="cb6-4" title="4">    a </a>
<a class="sourceLine" id="cb6-5" title="5">    (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>)) </a>
<a class="sourceLine" id="cb6-6" title="6">    b))</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">(define (sum-squares a b)</a>
<a class="sourceLine" id="cb6-9" title="9">  (sum </a>
<a class="sourceLine" id="cb6-10" title="10">    (<span class="kw">lambda</span> (x) (<span class="op">*</span> x x)) </a>
<a class="sourceLine" id="cb6-11" title="11">    a </a>
<a class="sourceLine" id="cb6-12" title="12">    (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">1</span>)) </a>
<a class="sourceLine" id="cb6-13" title="13">    b))</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15">(define (pi-sum a b)</a>
<a class="sourceLine" id="cb6-16" title="16">  (sum </a>
<a class="sourceLine" id="cb6-17" title="17">    (<span class="kw">lambda</span> (x) (<span class="op">+</span> (<span class="op">/</span> <span class="fl">1.0</span> (<span class="op">*</span> x (<span class="op">+</span> a <span class="dv">2</span>)))))</a>
<a class="sourceLine" id="cb6-18" title="18">    a</a>
<a class="sourceLine" id="cb6-19" title="19">    (<span class="kw">lambda</span> (x) (<span class="op">+</span> x <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb6-20" title="20">    b))</a></code></pre></div>
<p>可以看到，函数简洁且易读了很多，这就是抽象的力量。</p>
<h2 id="再抽象">2. 再抽象</h2>
<p><span class="math display">\[
\prod_{n = a}^{b} f(n) = f(a) * ... * f(b)
\]</span></p>
<p>与求和类似，我们也可以轻易地定义一个乘积的模板，只需将求和模板中的<code>+</code>改为<code>*</code>即可：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb7-1" title="1">(define (product term a next b)</a>
<a class="sourceLine" id="cb7-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-4" title="4">    (<span class="op">*</span> (term a)</a>
<a class="sourceLine" id="cb7-5" title="5">      (product term (next a) next b))))</a></code></pre></div>
<p>如果仔细观察的话，我们可以对模板<code>sum</code>和<code>product</code>再抽象成一个更高级的模板，就叫它<code>accumulate</code>吧：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb8-1" title="1">(define (accumulate combiner null-value term a next b)</a>
<a class="sourceLine" id="cb8-2" title="2">  (<span class="kw">if</span> (<span class="op">&gt;</span> a b)</a>
<a class="sourceLine" id="cb8-3" title="3">    null-value</a>
<a class="sourceLine" id="cb8-4" title="4">    (accumulate combiner (combiner (term a) null-value) term (next a) next b)))</a></code></pre></div>
<p>然后再重新定义一下<code>sum</code>和<code>product</code>：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb9-1" title="1">(define (product term a next b)</a>
<a class="sourceLine" id="cb9-2" title="2">  (accumulate</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="op">*</span></a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-5" title="5">  term</a>
<a class="sourceLine" id="cb9-6" title="6">  a</a>
<a class="sourceLine" id="cb9-7" title="7">  next</a>
<a class="sourceLine" id="cb9-8" title="8">  b))</a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10">(define (sum term a next b)</a>
<a class="sourceLine" id="cb9-11" title="11">  (accumulate</a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="op">+</span></a>
<a class="sourceLine" id="cb9-13" title="13">  <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-14" title="14">  term</a>
<a class="sourceLine" id="cb9-15" title="15">  a</a>
<a class="sourceLine" id="cb9-16" title="16">  next</a>
<a class="sourceLine" id="cb9-17" title="17">  b))</a></code></pre></div>
<p>又是一次成功的抽象，但是我们却会发现，这个更高级的抽象并没有给代码带来多大的提升，既没有使代码更精简，也没有使代码更可读。</p>
<p>一味地追求更高级的抽象并不是什么好事，很多纯粹的东西看起来很美，但是却无法在现实世界中立足。作为一个工程师，一个engineer，终究还是要以解决问题为主要目标的，在各种复杂条件下达成完美的妥协，又会有一种平衡之美，那是另一种不亚于纯粹之美的美好。</p>
<p>大三上软件工程的时候，某个我认为非常没水平的老师说软件工程的精髓在于trade-off，我觉得这也许是他说过最有水平的一句话了吧 :)</p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>SICP笔记 - 递归与迭代</title><published>Aug 20, 2018</published><updated>2020-03-06T11:20:44Z</updated><link href="http://jujuba.me/posts/sicp-recursion-iteration.html"/><id>http://jujuba.me/posts/sicp-recursion-iteration.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">SICP笔记 - 递归与迭代</h1>
<p class="date">Aug 20, 2018</p>
</header>
<p><img alt="sicp-cover" src="../imgs/sicp-cover.png" style="height: 300px;"/></p>
<p>这篇文章会很简短，因为我只准备谈一个简单的问题，就是递归与迭代之间的转换技巧。在我看了80页SICP之后，我觉得我有必要记下这个技巧，很难想象我从前从来没有总结过这个技巧，只是模糊地思考。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" title="1">(define (factorial n)</a>
<a class="sourceLine" id="cb1-2" title="2">  (<span class="kw">if</span> (<span class="op">=</span> n <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-4" title="4">    (<span class="op">*</span> n (factorial (<span class="op">-</span> n <span class="dv">1</span>)))))</a></code></pre></div>
<p>拿最简单的阶乘（Factorial）来说好了，当我们使用一段递归程序来计算6的阶乘的时候（譬如上面这段Lisp程序），稍微有点基础的人都知道，程序内部的堆栈是这样的：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb2-1" title="1">(factorial <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">(<span class="op">*</span> <span class="dv">6</span> (factorial <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb2-3" title="3">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (factorial <span class="dv">4</span>)))</a>
<a class="sourceLine" id="cb2-4" title="4">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (<span class="op">*</span> <span class="dv">4</span> (factorial <span class="dv">3</span>))))</a>
<a class="sourceLine" id="cb2-5" title="5">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (factorial <span class="dv">2</span>)))))</a>
<a class="sourceLine" id="cb2-6" title="6">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (<span class="op">*</span> <span class="dv">2</span> (factorial <span class="dv">1</span>))))))</a>
<a class="sourceLine" id="cb2-7" title="7">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> (<span class="op">*</span> <span class="dv">2</span> <span class="dv">1</span>)))))</a>
<a class="sourceLine" id="cb2-8" title="8">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (<span class="op">*</span> <span class="dv">4</span> (<span class="op">*</span> <span class="dv">3</span> <span class="dv">2</span>))))</a>
<a class="sourceLine" id="cb2-9" title="9">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> (<span class="op">*</span> <span class="dv">4</span> <span class="dv">6</span>)))</a>
<a class="sourceLine" id="cb2-10" title="10">(<span class="op">*</span> <span class="dv">6</span> (<span class="op">*</span> <span class="dv">5</span> <span class="dv">24</span>))</a>
<a class="sourceLine" id="cb2-11" title="11">(<span class="op">*</span> <span class="dv">6</span> <span class="dv">120</span>)</a>
<a class="sourceLine" id="cb2-12" title="12"><span class="dv">720</span></a></code></pre></div>
<p>现在请思考，如果要实现递归，我们最需要的计算机特性是什么？</p>
<p>我觉得应该是计算机可以保存现场与恢复现场的能力。打个比方，层层递归就好像往一条小路上走，一直走到尽头，但是在走的过程中，你必须记下路上的标记，因为你最终需要回到你走的起点。在这个例子中，程序想要知道<code>(* 6 (factorial 5))</code>的值，它就必须知道<code>(factorial 5)</code>的值，但是同时，它也必须记住<code>6</code>这个值，因为后续我们还会用到，只是现在它用不到罢了。</p>
<p>这样思考之后，递归的本质就明显了，我认为递归的本质就是迭代，不同之处在于，递归利用程序内部的堆栈来存储中间变量，而迭代使用参数来存储中间变量。如果想要将一段递归程序转换为一段迭代程序，只需增加几个参数即可，参数的个数取决于这段程序需要的中间变量的个数。</p>
<p>如此一来，计算阶乘的递归程序可以改写为以下的迭代程序：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb3-1" title="1">(define (factorial n)</a>
<a class="sourceLine" id="cb3-2" title="2">  (define (fact-iter product counter max-count)</a>
<a class="sourceLine" id="cb3-3" title="3">    (<span class="kw">if</span> (<span class="op">&gt;</span> counter max-count)</a>
<a class="sourceLine" id="cb3-4" title="4">      product</a>
<a class="sourceLine" id="cb3-5" title="5">      (fact-iter (<span class="op">*</span> counter product)</a>
<a class="sourceLine" id="cb3-6" title="6">                 (<span class="op">+</span> counter <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-7" title="7">                 max-count)))</a>
<a class="sourceLine" id="cb3-8" title="8">  (fact-iter <span class="dv">1</span> <span class="dv">1</span> n))</a></code></pre></div>
<p>除了递归程序中原有的参数<code>n</code>以外，这里又加上了<code>product</code>与<code>counter</code>参数，发现了吗？其实<code>product</code>与<code>counter</code>两个参数所扮演的角色就是堆栈在递归程序中所扮演的角色。所以递归程序如何变成迭代程序呢？加参数就可以了。</p>
<p>递归与迭代，一个用堆栈记录信息，一个用参数记录信息，仅此而已。</p>
<p>(The End)</p>
<!--

                            fib 5
                        /           \
                      /               \
                    /                   \
                  /                       \
                /                           \
             fib 4                        fib 3
           /        \                     /    \
          /          \                   /      \
         /            \                fib 2    fib 1
        /              \               /   \      |    
      fib 3           fib 2           /     \     |    
      /    \          /   \         fib 1  fib 0  1      
     /      \        /     \          |      |            
   fib 2    fib 1  fib 1  fib 0       |      |             
   /   \      |      |      |         1      0           
  /     \     |      |      |                 
fib 1  fib 0  1      1      0                     
  |      |      
  |      |      
  1      0  
-->
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>LLVM Pass与程序分析</title><published>Feb 23, 2020</published><updated>2020-03-06T11:20:43Z</updated><link href="http://jujuba.me/posts/program-analysis-via-llvm-pass.html"/><id>http://jujuba.me/posts/program-analysis-via-llvm-pass.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">LLVM Pass与程序分析</h1>
<p class="date">Feb 23, 2020</p>
</header>
<p><em>注：本文所用LLVM版本为3.8</em></p>
<h2 id="overview">0. Overview</h2>
<p>根据官方介绍，<a href="http://llvm.org/">LLVM</a> 是一堆模块化的，可复用的编译器以及工具链。LLVM Pass是其中非常重要的一部分，它可以让你对程序进行编译器级别的修改，但是又不需要你真的实现一个编译器。所谓编译器级别的修改——如果你对编译器有所了解的话，就知道编译器首先会通过lexical/syntax analysis将源代码解析成AST（abstract syntax tree，即语法树)，然后对AST进行semantic analysis以及各种各样的optimization，最后生成目标代码。在对AST进行分析的过程中，编译器会对AST进行一次或多次，局部或全局的分析，这些分析被模块化了之后，每个分析往往只负责一个相对独立的功能，这些分析也被称作Compiler Pass。LLVM会将源代码统一表示成LLVM自己定义的IR（intermediate representation，即中间表示），并基于IR生成AST，然后再将AST交给用户，让用户根据自己的需求去写Pass对程序进行分析。</p>
<p>这篇文章主要是关于用LLVM Pass来实现简化版taint analysis（污点分析）的核心部分。</p>
<h2 id="taint-analysis">1. Taint analysis</h2>
<p>Taint analysis可以被看作是信息流分析（Information Flow Analysis）的一种，主要是追踪数据在程序中的走向。具体实现的话，用static analysis（静态分析）或者dynamic analysis（动态分析）都可以。这里主要是用static analysis。我们要实现的简化版taint analysis，目标是找到程序中所有有可能被攻击者控制的变量。下面我尝试简洁地说明什么是taint analysis。</p>
<h4 id="几个问题">1.1 几个问题</h4>
<ul>
<li>为什么要追踪数据在程序中的走向？
<ul>
<li>这里主要是为了最大程度地识别潜在的恶意输入，从而提高程序的安全性。在现实世界中，攻击者的payload是多种多样的，我们往往无法预知攻击者的payload会以何种形式呈现（无法从形式上防范），但是我们知道许多payload都有一些共同的特征，比如说很多payload经过复杂的转换，最终会作为参数传入<code>system</code>函数，并执行恶意指令。通过追踪这些数据的走向，我们可以识别用户的输入是否具有这些特征。换句话说，在程序分析中，用户的原始输入长什么样并不重要，我们在意的是这段输入对于程序运行状态的影响。</li>
</ul></li>
<li>哪些数据是需要被追踪的
<ul>
<li>这里我们认为任何用户的输入都是不被信任的，所以任何来自用户的输入都应该被追踪。相似的，任何会被用户的输入影响的数据也都应该被追踪。</li>
</ul></li>
<li>数据是如何被追踪的
<ul>
<li>“追踪数据”是一个抽象的说法，具体到程序中，我们的做法就是找出程序中可能被攻击者控制的变量，然后监控那些变量是否会被用在某些危险的地方，如<code>system</code>函数中。</li>
</ul></li>
</ul>
<h4 id="几个概念">1.2 几个概念</h4>
<ul>
<li>source：指（不被信任的）数据的源头，这里我们可以简化为用户的输入。实际上source可以多种多样，任何可能被攻击者利用的输入都可以是source，比如一个配置文件，一个网络请求，或是一段音乐。</li>
<li>sink：指数据的出口，这里特指比较危险的函数，如C中的<code>system</code>（导致command injection）， PHP中的<code>echo</code>（导致XSS），等等。</li>
<li>tainted variable：指在程序中存储（不被信任的）数据的变量，也就是可能被攻击者控制的变量。</li>
<li>sanitize：指程序中变量从被追踪状态（tainted）到不被追踪状态（untainted）的过程，一般是由特定函数或者重新赋值来完成。比如说下面代码中第一行的<code>a</code>处于tainted状态，因为程序对用户输入没有进行任何处理，直接将用户输入作为<code>echo</code>的参数会导致XSS；但第三行中的<code>a</code>就处于sanitized（untainted）状态，因为此时<code>a</code>中的特殊字符被<code>htmlspecialchars</code>转义过，XSS攻击在这里失效了。如果我们只关心XSS攻击，那我们就没必要再追踪<code>a</code>这个变量了（除非<code>a</code>的值在之后又被改变了）。这里的的<code>htmlspecialchars</code>函数就可以叫做是XSS的sanitizer。</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode php"><code class="sourceCode php"><a class="sourceLine" id="cb1-1" title="1"><span class="dv">1</span> <span class="kw">$a</span> = user_input<span class="ot">();</span> <span class="co">// tainted</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="dv">2</span> <span class="kw">echo</span> <span class="kw">$a</span><span class="ot">;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="dv">3</span> <span class="kw">$a</span> = <span class="fu">htmlspecialchars</span><span class="ot">(</span><span class="kw">$a</span><span class="ot">);</span> <span class="co">// not tainted because of sanitization</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dv">4</span> <span class="kw">echo</span> <span class="kw">$a</span><span class="ot">;</span></a></code></pre></div>
<h2 id="strategy">2. Strategy</h2>
<h4 id="high-level-strategy">2.1 high-level strategy</h4>
<p>Taint analysis的难点在于已知source/sink的情况下，在茫茫多的变量中，如何精确地分辨source传过来的数据是否到达了sink。准确度很重要，如果不安全数据没有到达sink，但是你的分析却报了一条警告，那么这条警告就是false positive(FP)；如果不安全数据到达了sink，但是你的分析却报了一条警告，那么这条警告就是true negative(TN)。没有人喜欢FP或是TN，试想一下一个杀毒软件整天报告说你的正常文件是病毒，却又遗漏了真正的病毒。</p>
<p>要追踪不安全数据的传播（taint propagation），其实很简单，变量总是一步一步传播的。比如说变量<code>a</code>被tainted了，然后<code>b = a</code>，那我们就说<code>b</code>也被tainted了，就是这么简单。</p>
<p>Tainted variable的传播方式主要可以分为赋值指令、布尔指令、算数指令、分支指令等。其中值得注意的是布尔指令，布尔指令不是总能传播taintness的。考虑以下代码：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">bool</span> a = user_input(); <span class="co">// tainted</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="dt">bool</span> b = false; <span class="co">// not tainted</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">bool</span> res1 = a &amp; b; <span class="co">// not tainted</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="dt">bool</span> res2 = a || b; <span class="co">// still tainted</span></a></code></pre></div>
<p>我们可以看到<code>res1</code>不再处于tainted状态，而<code>res2</code>依然被tainted，背后的原因我这里就不说了。</p>
<p>布尔指令还涉及到追踪的精度问题，考虑以下代码：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">uint8_t</span> a = atoi(user_input()); <span class="co">// tainted</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">uint32_t</span> b = <span class="bn">0xfffffff</span>; <span class="co">// not tainted</span></a>
<a class="sourceLine" id="cb3-3" title="3">b &amp;= a; <span class="co">// tainted, but how?</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="dt">uint32_t</span> c = b &amp; <span class="bn">0xffff000</span>; <span class="co">// is c tainted?</span></a></code></pre></div>
<p>我们可以清楚地意识到第三行的<code>b</code>是一个tainted variable，也就意味着它可能被攻击者所控制，根据之前提到的逻辑，<code>c</code>当然也应该是tainted的，因为它的值是从<code>b</code>里来的。但是事实如此吗？我们注意到<code>a</code>的长度是8个bit，而<code>b</code>的值是通过与<code>a</code>进行&amp;操作得到的，也就是说攻击者至多只能控制<code>b</code>低位的8个bit，而<code>c</code>的值则完全不受<code>b</code>中低位的8个bit影响，所以实际上<code>c</code>并不应该被taint。</p>
<p>在下面的实现中，为简便起见，我们不考虑上面提到的布尔指令带来的问题，我们会简单粗暴地认为布尔指令也总是会传播taintness的。</p>
<h4 id="llvm-specific-strategy">2.2 LLVM-specific strategy</h4>
<p>如之前所说，在LLVM中，我们需要和LLVM IR生成出来的AST打交道，所以上述的high-level strategy必须落实到LLVM IR上才行。为了方便起见，这里的具体实现有所不同，上面说的是我们要先找到tainted data，然后追踪这些data如何在程序中传播。这里我使用的相反的策略，我打算找到程序中所有的常量（constant），那么除常量之外的，都是静态分析下无法确定具体值的变量，换句话说，它们的值是需要外部输入来确定的，也就是潜在的，可能被攻击者控制的值。 我们要关注的IR指令有以下几种：</p>
<ul>
<li><code>StoreInst</code>：语法是<code>store src, dst</code>，将src的值存到dst中，如果src的值是tainted的，那么dst的值也是tainted的</li>
<li><code>LoadInst</code>：语法是<code>dst = load src</code>，将src的值存到dst中，如果src的值是tainted的，那么dst的值也是tainted的</li>
<li><code>CmpInst</code>：用于比较数字的大小，包括整数与实数，假如该指令的一个或两个操作数被tainted，那么其结果也被tainted</li>
<li><code>CastInst</code>：用于类型转换，如果被转换的变量是tainted，那么转换后的变量也是tainted的</li>
<li><code>BinaryOperator</code>：所有二元操作符，包括算术指令，布尔指令等，虽然之前提到过布尔指令的问题，但是这里为了简化，直接定义成，如果两个操作数中有一个或两个是tainted的，那么它们的结果也是tainted的</li>
</ul>
<p>LLVM中IR是以不同的的scope组织起来的，常用的scope从大到小排列如下：Module &gt; Function &gt; BasicBlock &gt; Instruction。为了进行上述分析，我们可以通过遍历的方式来查看每一条instruction，看这些指令是不是我们所关心的，但是也有更好的办法。回忆上面说到的AST，LLVM提供了不同scope的visitor（visitor pattern是compiler里最常见的设计模式之一），我们需要用到的是<a href="https://llvm.org/doxygen/classllvm_1_1InstVisitor.html">InstVisitor</a>，顾名思义，InstVisitor会遍历AST中的每一条Instruction，我们只需重写我们关心的指令所对应的visit函数。</p>
<h2 id="implementation">3. Implementation</h2>
<p>首先我们需要做准备工作，即编译LLVM，这里我们使用LLVM3.8，编译大约需要20-40分钟不等。编译完成后，文章后面提到的所有LLVM相关程序如<code>opt</code>，<code>llvm-dis</code>等，都可以在<code>llvm/build/bin</code>目录下找到。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">mkdir</span> llvm<span class="kw">;</span> <span class="bu">cd</span> llvm</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="fu">wget</span> http://releases.llvm.org/3.8.0/llvm-3.8.0.src.tar.xz</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fu">wget</span> http://releases.llvm.org/3.8.0/cfe-3.8.0.src.tar.xz</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="fu">tar</span> xf llvm-3.8.0.src.tar.xz</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="fu">tar</span> xf cfe-3.8.0.src.tar.xz</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="fu">mv</span> llvm-3.8.0.src src</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="fu">mv</span> cfe-3.8.0.src src/tools/clang</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="fu">mkdir</span> build<span class="kw">;</span> <span class="bu">cd</span> build</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="fu">cmake</span> ../src</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="fu">make</span></a></code></pre></div>
<p>然后开始写代码，首先我们需要新建一个struct并继承InstVisitor，并建立一个<code>std::set</code>来存储所有的常量。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">struct</span> TaintInstVisitor : <span class="kw">public</span> InstVisitor&lt;TaintInstVisitor&gt; {</a>
<a class="sourceLine" id="cb5-2" title="2">  TaintInstVisitor() {}</a>
<a class="sourceLine" id="cb5-3" title="3">  ~TaintInstVisitor() {}</a>
<a class="sourceLine" id="cb5-4" title="4">  set&lt;Value*&gt; const_vars;</a>
<a class="sourceLine" id="cb5-5" title="5">}</a></code></pre></div>
<p>另外，我们需要一个判定常量的方法，这里我们使用LLVM自带的<code>isa&lt;Constant&gt;()</code>方法来检测目标变量是否是常量，如果一个变量是常量，那么我们就将这个常量加入上面定义的<code>const_vars</code>中；如果一个变量的值是从常量派生而来的，那我们也将它加入<code>const_vars</code>中，所以我们检测一个变量是否是常量的函数可以写成如下形式：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">struct</span> TaintInstVisitor : <span class="kw">public</span> InstVisitor&lt;TaintInstVisitor&gt; {</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="dt">bool</span> is_constant (Value* v) {</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="cf">return</span> (const_vars.find(v) != const_vars.end()) || (isa&lt;Constant&gt;(v));</a>
<a class="sourceLine" id="cb6-5" title="5">  }</a>
<a class="sourceLine" id="cb6-6" title="6">}</a></code></pre></div>
<p>接下来我们实现如何判断一个变量是否由常量派生而来。首先是<code>StoreInst</code>，判断方式很简单，如果<code>src</code>是常量，那么<code>dst</code>也是常量</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">struct</span> TaintInstVisitor : <span class="kw">public</span> InstVisitor&lt;TaintInstVisitor&gt; {</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="dt">void</span> visitStoreInst(StoreInst &amp;I) {</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="co">// syntax: store src, dst</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="co">// if src is a constant, then dst is a constant</span></a>
<a class="sourceLine" id="cb7-6" title="6">    Value *op1 = I.getOperand(<span class="dv">0</span>); <span class="co">// src</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="cf">if</span> (is_constant(op1)) {</a>
<a class="sourceLine" id="cb7-8" title="8">      Value *operand2 = I.getOperand(<span class="dv">1</span>); <span class="co">// dst</span></a>
<a class="sourceLine" id="cb7-9" title="9">      const_vars.insert(operand2);</a>
<a class="sourceLine" id="cb7-10" title="10">    }</a>
<a class="sourceLine" id="cb7-11" title="11">  }</a>
<a class="sourceLine" id="cb7-12" title="12">}</a></code></pre></div>
<p>然后是<code>LoadInst</code>与<code>CastInst</code>，同样的如果<code>src</code>是常量，那么<code>dst</code>也是常量。在这里必须要提一下LLVM精巧的设计，在LLVM中，各种<code>Instruction</code>是继承自<code>Value</code>的，你可以通过<code>Insturction</code>的各种方法来得到关于这条指令的各种信息，而这个<code>Instruction</code>本身的值则代表了这条指令的返回值。比如说，<code>load src</code>，我们知道这条指令是将<code>src</code>的值赋给另一个变量，但是这个变量怎么表示呢？在LLVM里，<code>load src</code>这条指令本身就代表了被赋值的那个变量。在单操作数的指令中，如<code>LoadInst</code>与<code>CastInst</code>，这条指令本身就代表了那个被赋值的变量。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">struct</span> TaintInstVisitor : <span class="kw">public</span> InstVisitor&lt;TaintInstVisitor&gt; {</a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="dt">void</span> visitLoadInst(LoadInst &amp;I) {</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="co">// syntax: dst = load src</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="co">// if src is a const, then dst is a const</span></a>
<a class="sourceLine" id="cb8-6" title="6">    Value *op = I.getOperand(<span class="dv">0</span>); <span class="co">// src</span></a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="cf">if</span> (is_constant(op)) { <span class="co">// src is a const</span></a>
<a class="sourceLine" id="cb8-8" title="8">      const_vars.insert(&amp;I); <span class="co">// dst is also a const</span></a>
<a class="sourceLine" id="cb8-9" title="9">    }</a>
<a class="sourceLine" id="cb8-10" title="10">  }</a>
<a class="sourceLine" id="cb8-11" title="11">  <span class="dt">void</span> visitCastInst(CastInst &amp;I) {</a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="co">// syntax: dst = load src</span></a>
<a class="sourceLine" id="cb8-13" title="13">    Value *op = I.getOperand(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="cf">if</span> (is_constant(op)) {</a>
<a class="sourceLine" id="cb8-15" title="15">      const_vars.insert(&amp;I);</a>
<a class="sourceLine" id="cb8-16" title="16">    }</a>
<a class="sourceLine" id="cb8-17" title="17">  }</a>
<a class="sourceLine" id="cb8-18" title="18">}</a></code></pre></div>
<p>剩下的则是各种二元操作符，包括比较，算术，布尔指令，等等，我们可以用一个统一的函数来处理它们。这里我们简单粗暴地认为只有当二元操作符的两个操作数都是常量的时候，我们才认为这个被赋值的变量也是一个常量。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">struct</span> TaintInstVisitor : <span class="kw">public</span> InstVisitor&lt;TaintInstVisitor&gt; {</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="dt">void</span> visitCmpInst(CmpInst &amp;I) {</a>
<a class="sourceLine" id="cb9-4" title="4">    handle_binaryOp(I);</a>
<a class="sourceLine" id="cb9-5" title="5">  }</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="dt">void</span> visitBinaryOperator(BinaryOperator &amp;I) {</a>
<a class="sourceLine" id="cb9-8" title="8">    handle_binaryOp(I);</a>
<a class="sourceLine" id="cb9-9" title="9">  }</a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11">  <span class="dt">void</span> handle_binaryOp(Instruction&amp; I) {</a>
<a class="sourceLine" id="cb9-12" title="12">    Value *op1 = I.getOperand(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb9-13" title="13">    Value *op2 = I.getOperand(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="co">// </span><span class="al">TODO</span><span class="co">: actually boolean operator don't follow: &amp;&amp;, ||, &amp;, |</span></a>
<a class="sourceLine" id="cb9-15" title="15">    <span class="cf">if</span> (is_constant(op1) &amp;&amp; is_constant(op2)) {</a>
<a class="sourceLine" id="cb9-16" title="16">      const_vars.insert(&amp;I);</a>
<a class="sourceLine" id="cb9-17" title="17">    }</a>
<a class="sourceLine" id="cb9-18" title="18">  }</a>
<a class="sourceLine" id="cb9-19" title="19">}</a></code></pre></div>
<p>最后我们创建一个<code>TaintInstVisitor</code>的实例，并将其运行于这个Module，最后我们将检测到的所有常量打印出来：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">struct</span> Hello : <span class="kw">public</span> ModulePass {</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">struct</span> TaintInstVisitor : <span class="kw">public</span> InstVisitor&lt;TaintInstVisitor&gt; {</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb10-4" title="4">  }</a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="kw">virtual</span> <span class="dt">bool</span> runOnModule(Module &amp;M) {</a>
<a class="sourceLine" id="cb10-6" title="6">    TaintInstVisitor tv;</a>
<a class="sourceLine" id="cb10-7" title="7">    tv.visit(M);</a>
<a class="sourceLine" id="cb10-8" title="8">    set&lt;Value*&gt; const_vars = tv.get_const_vars();</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="cf">for</span> (<span class="kw">auto</span> it = const_vars.begin(); it != const_vars.end(); it++) {</a>
<a class="sourceLine" id="cb10-10" title="10">      errs() &lt;&lt; *<span class="kw">static_cast</span>&lt;Instruction*&gt;(*it) &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</a>
<a class="sourceLine" id="cb10-11" title="11">    }</a>
<a class="sourceLine" id="cb10-12" title="12">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb10-13" title="13">  }</a>
<a class="sourceLine" id="cb10-14" title="14">}</a></code></pre></div>
<h2 id="run">4. Run</h2>
<p>写完了Pass，下面就要开始运行了。首先我们要知道LLVM Pass运行于LLVM的bitcode上，一般我们通过使用clang编译来得到bitcode：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="fu">clang</span> -emit-llvm -o a.out.bc -c test.c</a></code></pre></div>
<p>而我则偏好用<a href="https://github.com/travitch/whole-program-llvm/">wllvm</a>来得到bitcode，wllvm是Python写的，你可以通过pip来安装它，然后用如下命令取得bitcode：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="ex">wllvm</span> test.bc</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="ex">extract-bc</span> a.out <span class="co"># generate bitcode file called a.out.bc</span></a></code></pre></div>
<p>wllvm的优势在于，当你在编译一个拥有许多源文件的project时，你也可以通过上面这两条简单的指令来获取整个项目的bitcode。</p>
<p>获取bitcode之后，我们使用LLVM的opt来运行它，这里我们写的Pass叫做Hello，我们可以使用如下命令来运行这个Pass</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1"><span class="ex">opt</span> -load LLVMHello.so -Hello <span class="op">&lt;</span> a.out.bc <span class="op">&gt;</span> /dev/null</a></code></pre></div>
<h2 id="verify">5. Verify</h2>
<p>下面我们通过下面这个简单的程序来验证一下，其中只有<code>b</code>是常量，其他变量都是可以被攻击者控制的。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="dt">int</span> a = argc;</a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="dt">int</span> b = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="dt">int</span> c = a + b;</a>
<a class="sourceLine" id="cb14-7" title="7">  printf(<span class="st">"%d</span><span class="sc">\n</span><span class="st">"</span>, c);</a>
<a class="sourceLine" id="cb14-8" title="8">}</a></code></pre></div>
<p>使用上面提到的方法运行Pass，打印如下结果：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode llvm"><code class="sourceCode llvm"><a class="sourceLine" id="cb15-1" title="1">  <span class="fu">%b</span> = <span class="kw">alloca</span> <span class="dt">i32</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="fu">%2</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%b</span>, <span class="kw">align</span> <span class="dv">4</span></a></code></pre></div>
<p>这说明该程序中共有两个变量的值为常量，第一个是<code>b</code>，第二个是<code>%2</code>。其中<code>%2</code>是一个临时变量，它的值是通过load变量b的值得到的，也就是说它的值完全等于<code>b</code>的值。由此来看，输出结果与我们之前的分析相符。</p>
<p>我们可以通过<code>llvm-dis</code>将bitcode转换为IR，再来验证一下Pass输出的正确性。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb16-1" title="1"><span class="ex">llvm-dis</span> a.out.bc</a></code></pre></div>
<p>上述命令会生成IR文件，名为<code>a.out.ll</code>，主要内容如下：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode llvm"><code class="sourceCode llvm"><a class="sourceLine" id="cb17-1" title="1"><span class="fu">@.str</span> = <span class="kw">private</span> unnamed_addr <span class="kw">constant</span> [<span class="dv">4</span> x <span class="dt">i8</span>] c<span class="st">"%d\0A\00"</span>, <span class="kw">align</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">; Function Attrs: nounwind uwtable</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="kw">define</span> <span class="dt">i32</span> <span class="fu">@main</span>(<span class="dt">i32</span> <span class="fu">%argc</span>, <span class="dt">i8</span>** <span class="fu">%argv</span>) #<span class="dv">0</span> {</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="fu">entry:</span></a>
<a class="sourceLine" id="cb17-6" title="6">  <span class="fu">%argc.addr</span> = <span class="kw">alloca</span> <span class="dt">i32</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-7" title="7">  <span class="fu">%argv.addr</span> = <span class="kw">alloca</span> <span class="dt">i8</span>**, <span class="kw">align</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb17-8" title="8">  <span class="fu">%a</span> = <span class="kw">alloca</span> <span class="dt">i32</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="fu">%b</span> = <span class="kw">alloca</span> <span class="dt">i32</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-10" title="10">  <span class="fu">%c</span> = <span class="kw">alloca</span> <span class="dt">i32</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-11" title="11">  <span class="kw">store</span> <span class="dt">i32</span> <span class="fu">%argc</span>, <span class="dt">i32</span>* <span class="fu">%argc.addr</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-12" title="12">  <span class="kw">store</span> <span class="dt">i8</span>** <span class="fu">%argv</span>, <span class="dt">i8</span>*** <span class="fu">%argv.addr</span>, <span class="kw">align</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb17-13" title="13">  <span class="fu">%0</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%argc.addr</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-14" title="14">  <span class="kw">store</span> <span class="dt">i32</span> <span class="fu">%0</span>, <span class="dt">i32</span>* <span class="fu">%a</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-15" title="15">  <span class="kw">store</span> <span class="dt">i32</span> <span class="dv">1</span>, <span class="dt">i32</span>* <span class="fu">%b</span>, <span class="kw">align</span> <span class="dv">4</span> <span class="co">; %b is a constant</span></a>
<a class="sourceLine" id="cb17-16" title="16">  <span class="fu">%1</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%a</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-17" title="17">  <span class="fu">%2</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%b</span>, <span class="kw">align</span> <span class="dv">4</span> <span class="co">; %2 is a constant</span></a>
<a class="sourceLine" id="cb17-18" title="18">  <span class="fu">%add</span> = <span class="kw">add</span> <span class="kw">nsw</span> <span class="dt">i32</span> <span class="fu">%1</span>, <span class="fu">%2</span></a>
<a class="sourceLine" id="cb17-19" title="19">  <span class="kw">store</span> <span class="dt">i32</span> <span class="fu">%add</span>, <span class="dt">i32</span>* <span class="fu">%c</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-20" title="20">  <span class="fu">%3</span> = <span class="kw">load</span> <span class="dt">i32</span>, <span class="dt">i32</span>* <span class="fu">%c</span>, <span class="kw">align</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb17-21" title="21">  <span class="fu">%call</span> = <span class="kw">call</span> <span class="dt">i32</span> (<span class="dt">i8</span>*, ...) <span class="fu">@printf</span>(<span class="dt">i8</span>* <span class="kw">getelementptr</span> <span class="kw">inbounds</span> ([<span class="dv">4</span> x <span class="dt">i8</span>], [<span class="dv">4</span> x <span class="dt">i8</span>]* <span class="fu">@.str</span>, <span class="dt">i32</span> <span class="dv">0</span>, <span class="dt">i32</span> <span class="dv">0</span>), <span class="dt">i32</span> <span class="fu">%3</span>)</a>
<a class="sourceLine" id="cb17-22" title="22">  <span class="kw">ret</span> <span class="dt">i32</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-23" title="23">}</a></code></pre></div>
<p>通过查看IR我们可以发现，Pass的输出结果是正确的，在这个程序里，只有<code>%b</code>和<code>%2</code>的值是常量，而其他的值都是潜在的可以被攻击者控制的值。</p>
<h2 id="more-about-llvm">6. More about LLVM</h2>
<p>利用LLVM Pass还可以做很多很多事，简单的比如说生成call graph，control flow graph之类的，或者找出代码中所有的循环；稍微复杂点的，就不只是分析，可能会涉及到instrumentation，也就是利用LLVM更改程序行为，比如说在源代码中引入一个新的函数，并在所有特定类型的指令之后都插入该函数的调用。</p>
<p>当然LLVM也不是无所不能的，比如它不适用于没有源代码的项目，对于这种情况，或许使用来自Intel的Pin来做动态分析显得更为合适。</p>
<h2 id="taint-analysis-and-others">7. Taint analysis and others</h2>
<h4 id="implicit-flows">7.1 Implicit flows</h4>
<p>文章写到这里，看起来taint analysis已经很强大了，可事实上依旧存在它难以处理的情况，比如implicit flows。</p>
<p>考虑以下代码：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1">x   =   user_input(); <span class="co">// tainted</span></a>
<a class="sourceLine" id="cb18-2" title="2">y   =   x; <span class="co">// tainted</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="cf">if</span> (y == <span class="dv">0</span>) { <span class="co">// tainted</span></a>
<a class="sourceLine" id="cb18-4" title="4">    z   =   <span class="dv">2</span>; <span class="co">// not tainted</span></a>
<a class="sourceLine" id="cb18-5" title="5">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb18-6" title="6">    z   =   <span class="dv">1</span>; <span class="co">// not tainted</span></a>
<a class="sourceLine" id="cb18-7" title="7">}   </a>
<a class="sourceLine" id="cb18-8" title="8">system(z);</a></code></pre></div>
<p>沿用我们之前写的analysis，我们会得出<code>x</code>和<code>y</code>是tainted的而<code>z</code>并不是tainted的结论，进而得出“<code>system(z)</code>是安全的”这样一个结论。但是事实真的如此吗？我们注意到当<code>y</code>的值为0的时候，<code>z</code>的值必定是2；而当<code>y</code>的值不为0时，<code>z</code>的值必定为1。换句话说，<code>z</code>的值是由<code>y</code>的值来决定的，不同于上面提到的任何一种方式，这种方式是间接的，通过控制流（control flow）而非数据流（data flow）来决定的。</p>
<p>这时候，我们实际上陷入了一个进退两难的境地。激进的做法是，如果决定分支的变量与用户输入有关，则taint该分支中所有的变量，这会导致over-taint，很多不该被taint的变量最后也被taint了；保守的做法是，放弃在taint analysis中检测implicit flows，也就是说，在上面的代码中，<code>z</code>将不会被标记为tainted。不过，无论选择那一种做法，都是不完美的，都会导致分析的结果出现偏差。</p>
<p>所以就没有更好的办法了吗？说实话，我也并不是很清楚。不过如果你有兴趣，我会建议你google一下“causality inference taint analysis”，也许你会发现比taint analysis更好的方法。</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>用Makefile管理blog</title><published>May 26, 2018</published><updated>2020-03-06T11:28:35Z</updated><link href="http://jujuba.me/posts/my-blog-management.html"/><id>http://jujuba.me/posts/my-blog-management.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">用Makefile管理blog</h1>
<p class="date">May 26, 2018</p>
</header>
<p><img alt="Generating blog using Make" height="250" src="../imgs/make_blog.png"/></p>
<ul>
<li><ol start="0" type="1">
<li><a href="#overview">Overview</a></li>
</ol></li>
<li><ol type="1">
<li><a href="#markdown">Markdown</a></li>
</ol></li>
<li><ol start="2" type="1">
<li><a href="#pandoc">Pandoc</a></li>
</ol>
<ul>
<li>2.1 <a href="#metadata">Converting with metadata - internal YAML</a></li>
<li>2.2 <a href="#template">Converting with template - external YAML</a></li>
<li>2.3 <a href="#css">Converting with style - CSS</a></li>
<li>2.4 <a href="#latex"><span class="math inline">\(\LaTeX\)</span>?</a></li>
</ul></li>
<li><ol start="3" type="1">
<li><a href="#makefile">Makefile</a></li>
</ol></li>
<li><ol start="4" type="1">
<li><a href="#rss">RSS</a></li>
</ol></li>
<li><ol start="5" type="1">
<li><a href="#sync">Synchronize</a></li>
</ol></li>
</ul>
<p><a name="overview"></a></p>
<h2 id="overview">0. Overview</h2>
<p>印象中我搭过三次博客，两次搭在了Github Pages上，分别使用了Jekyll和Hexo，不过那时候菜得要死，没什么好写的东西，也没能力去扩展现有的框架，不过搭建博客的过程还是让当时的我学到了一些东西。后来我买了服务器，搭了一个博客在上面，记过一些笔记，却一直没有给它配一个域名（因为不知道买哪个，选择困难晚期），后来那个博客也就不了了之。</p>
<p>这算是我第四次开博客了，不同的是我不再是当年的菜鸟了，有时候我真的觉得我有一些东西想和这个世界上的一些人分享 :)</p>
<p>这次的博客依然采用Markdown写作，我选择Pandoc将其转为HTML，并使用GNU Make来进行批量管理。这篇文章主要讲述我如何使用这三种工具来手动管理我的博客。</p>
<p><a name="markdown"></a></p>
<h2 id="markdown">1. <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a></h2>
<p>Markdown作为一种轻量级标记语言而被广大程序员所熟知，它简单明了，非常适合用在博客的写作上。它的语法简单，比如’#’可以用来指定标题的大小，<code># Header 1</code>一般会被转化成<code>&lt;h1&gt; Header 1 &lt;/h1&gt;</code>，<code>## Header 2</code>被转换成<code>&lt;h2&gt; Header 2 &lt;/h2&gt;</code>，等等，我不打算在这里大谈Markdown的语法，具体语法可以参考<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">这里</a>。</p>
<p>Markdown的简单明了伴随着表达力不足的问题，但一般可以通过内嵌HTML的方式来解决。比如图片大小的设置，在Markdown中，如果要插入一副图片，语法是</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb1-1" title="1"><span class="al">![alt text](../imgs/make_blog.png)</span></a></code></pre></div>
<p>可是问题在于标准的Markdown的语法并没有提供指定图片大小的方式，于是它就会默认使用图片的原大小，which is 非常不好的。事实上，我很少用这个语法，如果我想要引入一张图片，例如上面的题图，我会使用标准的HTML语法来引入</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">"../imgs/make_blog.png"</span><span class="ot"> alt=</span><span class="st">"alt text"</span><span class="ot"> height=</span><span class="st">"250"</span><span class="kw">/&gt;</span></a></code></pre></div>
<p>总而言之，我还是很喜欢Markdown的，我觉得它作为一个方便写作的标记语言还算是称职的，尽管有些标记符设计得有些问题。我无法要求它能表达所有HTML都能表达的东西，毕竟那样的话，Markdown就成了另一个HTML :)</p>
<p><a name="pandoc"></a></p>
<h2 id="pandoc">2. <a href="https://pandoc.org/">Pandoc</a></h2>
<p>Pandoc是一款由Haskell写成的，<a href="https://github.com/jgm/pandoc">开源</a>的通用文档转换工具，自称文档转换届的瑞士军刀（Pandoc官网上自己说的）。我从中挑了一把Markdown to HTML的小刀用了一下，发现这把刀真是异常锋利。</p>
<p>Pandoc的基础语法很简单，写完Markdown之后，使用以下命令将其转换为HTML文件，</p>
<pre><code>// Converting test.md from (-f) markdown to (-t) html and output (-o) test.html
pandoc test.md -f markdown -t html -o test.html</code></pre>
<p><a name="metadata"></a></p>
<h3 id="converting-with-metadata---internal-yaml">2.1 Converting with metadata - internal YAML</h3>
<p>Pandoc支持在Markdown文件中嵌入YAML，叫做<a href="https://pandoc.org/MANUAL.html#extension-yaml_metadata_block"><code>yaml_metadata_block</code></a>，顾名思义，这个是用来控制这个Markdown文件的Metadata的。YAML语法块以<code>---</code>开始，也以<code>---</code>结束，一般，我会在我的Markdown文件的YAML语法块中嵌入以下信息：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">---</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="fu">title:</span><span class="at"> 我如何手动管理我的博客</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fu">keywords:</span></a>
<a class="sourceLine" id="cb4-4" title="4">    GNU Make, YAML, Pandoc, Markdown, HTML</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="fu">author:</span></a>
<a class="sourceLine" id="cb4-6" title="6">    Jiahao Cai</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="ot">---</span></a></code></pre></div>
<p>这些信息会被Pandoc所提取，并写在生成的HTML文件中，上面的语法块会被转化成以下代码：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb5-1" title="1">  <span class="co">&lt;!-- 在head中增加以下代码 --&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">"author"</span><span class="ot"> content=</span><span class="st">"Jiahao Cai"</span> <span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">"keywords"</span><span class="ot"> content=</span><span class="st">"GNU Make, YAML, Pandoc, Markdown, HTML"</span> <span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">&lt;title&gt;</span>我如何手动管理我的博客<span class="kw">&lt;/title&gt;</span></a></code></pre></div>
<p>以及</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb6-1" title="1">  <span class="co">&lt;!-- 在body中增加以下代码 --&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="kw">&lt;header&gt;</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="kw">&lt;h1</span><span class="ot"> class=</span><span class="st">"title"</span><span class="kw">&gt;</span>我如何手动管理我的博客<span class="kw">&lt;/h1&gt;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">"author"</span><span class="kw">&gt;</span>Jiahao Cai<span class="kw">&lt;/p&gt;</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="kw">&lt;/header&gt;</span></a></code></pre></div>
<p>不过此时如果你用了我之前给的命令<code>pandoc test.md -f markdown -t html -o test.html</code>，你会发现转换出来的HTML并没有title／author／keyword，这是因为Pandoc默认只生成HTML fragment：</p>
<blockquote>
<p>By default, pandoc produces a document fragment. To produce a standalone document (e.g. a valid HTML file including &lt;head&gt; and &lt;body&gt;), use the -s or –standalone flag</p>
</blockquote>
<p>所以只要使用<code>pandoc test.md -f markdown -t html --standalone -o test.html</code>就可以生成完整的HTML文件了。</p>
<p><strong>至此，如果你没有更多的需求，那么Markdown转HTML的部分已经结束了，上面的命令已经足够了。接下来讲的是如何通过一个外部的YAML文件在所有转换出的HTML文件中插入相同的内容，使用CSS美化生成的HTML文件以及如何插入<span class="math inline">\(\LaTeX\)</span>。</strong></p>
<hr/>
<p><a name="template"></a></p>
<h3 id="converting-with-template---external-yaml">2.2 Converting with template - external YAML</h3>
<p>上面所提到的YAML代码块一般都独立分布在各个Markdown文件中，毕竟每个文件的title都是不一样的。此时万一我有个通用的需求，所有的Markdown文件都需要满足，我是否可以将它抽离出来呢？Pandoc可以，我们可以通过一个外部的YAML文件来实现一个template。</p>
<p>我对所有的HTML文件都至少有如下需求：</p>
<ul>
<li>说明当前页面为中文</li>
<li>使用相同的favicon</li>
<li>移动端适配</li>
<li>嵌入Google analytics的代码</li>
<li>在文件的结尾加上[Return to the homepage]的按钮</li>
</ul>
<p>我可以将这些要求单独放到一个YAML文件里，然后将Markdown文件作为source，YAML作为模板，共同生成每个HTML文件。根据上述的需求，我写了如下YAML文件（关于Pandoc中YAML支持的属性，请查看<a href="https://pandoc.org/MANUAL.html#templates">这里</a>）：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">---</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">lang:</span><span class="at"> zh</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">header-includes:</span></a>
<a class="sourceLine" id="cb7-5" title="5">    &lt;link rel=<span class="st">"icon"</span> href=<span class="st">"../imgs/favicon.ico"</span> type=<span class="st">"image/x-icon"</span>/&gt;</a>
<a class="sourceLine" id="cb7-6" title="6">    &lt;link rel=<span class="st">"shortcut icon"</span> href=<span class="st">"../imgs/favicon.ico"</span> type=<span class="st">"image/x-icon"</span> /&gt; </a>
<a class="sourceLine" id="cb7-7" title="7">    &lt;meta name=<span class="st">"viewport"</span> content=<span class="st">"width=device-width, initial-scale=1"</span> /&gt;  </a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9">    &lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;</a>
<a class="sourceLine" id="cb7-10" title="10">    &lt;script async src=<span class="st">"https://www.googletagmanager.com/gtag/js?id=UA-116308654-1"</span>&gt;&lt;/script&gt;</a>
<a class="sourceLine" id="cb7-11" title="11">    &lt;script&gt;</a>
<a class="sourceLine" id="cb7-12" title="12">    window.dataLayer = window.dataLayer || <span class="kw">[]</span>;</a>
<a class="sourceLine" id="cb7-13" title="13">    function gtag()<span class="kw">{</span>dataLayer.push(arguments);<span class="kw">}</span></a>
<a class="sourceLine" id="cb7-14" title="14">    gtag(<span class="st">'js'</span>, new Date());</a>
<a class="sourceLine" id="cb7-15" title="15">    gtag(<span class="st">'config'</span>, <span class="st">'UA-116308654-1'</span>);</a>
<a class="sourceLine" id="cb7-16" title="16">    &lt;/script&gt;</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="fu">include-after:</span></a>
<a class="sourceLine" id="cb7-19" title="19">    &lt;a style=<span class="st">"color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;"</span> href=<span class="st">"../index.html"</span>&gt;<span class="kw">[</span>Return to the homepage<span class="kw">]</span>&lt;/a&gt;</a>
<a class="sourceLine" id="cb7-20" title="20"><span class="ot">---</span></a></code></pre></div>
<p>然后我们再加上一个参数<code>template.yaml</code>，指定模板来生成HTML文件</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="ex">pandoc</span> template.yaml test.md -f markdown -t html --standalone -o test.html</a></code></pre></div>
<p>这样一来，我们就可以只修改<code>template.yaml</code>中的代码，然后将所有Markdown文件重新转换成HTML文件即可。听起来还是很复杂对吧，不要着急，我们可以用一个Makefile来简化这一切 :)</p>
<p><a name="css"></a></p>
<h3 id="converting-with-style---css">2.3 Converting with style - CSS</h3>
<p>Pandoc也可以为生成的HTML文件来指定CSS，我使用的CSS是从Github Gist上找来的，地址在<a href="https://gist.github.com/killercup/5917178">这里</a>。使用方法很简单，加上<code>--css style.css</code>参数即可。现在我们的参数更复杂了，变成了</p>
<pre><code>pandoc template.yaml test.md -f markdown --css style.css -t html --standalone -o test.html</code></pre>
<p><a name="latex"></a></p>
<h3 id="latex">2.4 <span class="math inline">\(\LaTeX\)</span>?</h3>
<p>写Markdown的同时也会有要写LaTeX的需求，比如我在<a href="reservoir_computing.html">Reservoir computing简介</a>里写的那些公式。Pandoc也支持在Markdown中插入LaTeX公式，使用方法很简单，就跟真正的LaTeX中Math mode一样，可以在两个$之间或者两个$$之间插入公式。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode latex"><code class="sourceCode latex"><a class="sourceLine" id="cb10-1" title="1"><span class="ss">$$</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="sc">\boldsymbol</span><span class="ss">{r}(t + </span><span class="sc">\Delta</span><span class="ss"> t) = (1 - </span><span class="sc">\alpha</span><span class="ss">)</span><span class="sc">\boldsymbol</span><span class="ss">{r}(t) + </span><span class="sc">\alpha\tanh</span><span class="ss">(</span><span class="sc">\boldsymbol</span><span class="ss">{Ar}(t) + </span><span class="sc">\boldsymbol</span><span class="ss">{W}_{in}</span><span class="sc">\boldsymbol</span><span class="ss">{u}(t) + </span><span class="sc">\xi</span><span class="ss"> 1)</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ss">$$</span> </a></code></pre></div>
<p>会被转化成</p>
<p><span class="math display">\[
\boldsymbol{r}(t + \Delta t) = (1 - \alpha)\boldsymbol{r}(t) + \alpha\ tanh(\boldsymbol{Ar}(t) + \boldsymbol{W}_{in}\boldsymbol{u}(t) + \xi 1)
\]</span></p>
<p>使用LaTeX需要加入<code>--mathjax</code>参数，此时我们的命令变成了</p>
<pre><code>pandoc template.yaml test.md -f markdown --css style.css -t html --standalone --mathjax -o test.html</code></pre>
<p><a name="makefile"></a></p>
<h2 id="makefile">3. Makefile</h2>
<p>终于到了Makefile了，下面我们要做的就是写一个Makefile简化上述所有的流程，我现在使用的是GNU Make。Makefile还有个优势就是，当所有目标文件都生成之后，再次执行Makefile时，当且仅当目标文件的依赖文件被修改过时，目标文件才会被重新生成，如下图所示。此处我<code>make</code>之后，只修改了<code>thoughts.md</code>，于是下次<code>make</code>的时候，便只生成目标文件<code>thoughts.html</code>了。</p>
<p><img alt="Generating blog using Make" height="250" src="../imgs/make_blog.png"/></p>
<p>关于Makefile的语法，我这里还是不多说了，这语法并不是很友好，很多不好的遗留的设计，单独写出来估计能写本小册子了，我就偷个懒，直接把我的Makefile贴在这里了。总之，用了它之后，我可以专心写Markdown，写完就<code>make</code>或者<code>make clean</code>就完事了，还是挺方便的。虽然之前折腾得挺多，不过我就喜欢折腾 :)</p>
<pre class="samp">CSS = ../style.css
FLAG = --standalone --mathjax
SRC = src
TEMPLATE = template.yaml
MD = \
reservoir_computing\
thoughts\
shadowsocks_in_ruby\
quote_from_jobs\
terminal_music\
apply_master_in_sweden\
stockholm_visit\
my_blog_management

HTML = $(MD:%=%.html)

all: $(HTML)

%.html: $(SRC)/%.md $(TEMPLATE) $(CSS)
    @echo Converting $&lt; to $@
    @pandoc $(TEMPLATE) $&lt; -f markdown --css $(CSS) -t html $(FLAG) -o $@

clean:
    rm $(HTML)
</pre>
<p>我把博客文章的目录结构也贴在这里，方便大家理解上面的Makefile</p>
<pre class="samp">.
├── Makefile
├── apply_master_in_sweden.html
├── my_blog_management.html
├── quote_from_jobs.html
├── reservoir_computing.html
├── shadowsocks_in_ruby.html
├── stockholm_visit.html
├── terminal_music.html
├── thoughts.html
├── src
│   ├── apply_master_in_sweden.md
│   ├── my_blog_management.md
│   ├── quote_from_jobs.md
│   ├── reservoir_computing.md
│   ├── shadowsocks_in_ruby.md
│   ├── stockholm_visit.md
│   ├── terminal_music.md
│   └── thoughts.md
└── template.yaml
</pre>
<p><a name="rss"></a></p>
<h2 id="rss">4. RSS</h2>
<p><a href="https://en.wikipedia.org/wiki/RSS">RSS</a> (Rich Site Summary 或 Really Simple Syndication) 是一种网站主动提供的服务，使用一种标准化的格式来描述网站的更新情况，从而使得用户可以轻易地订阅一个网站，即定时地从该网站的RSS源获取信息。这种主动提供服务的好处就是用户不必经常通过访问网站来了解该网站是否有更新，更新在何处，用户可以通过RSS阅读器来第一时间获取网站的更新。</p>
<p>RSS一般由一个XML文件来表达，它并没有一个官方的标准，我这里使用的是<a href="https://validator.w3.org/feed/docs/atom.html">Atom</a>。</p>
<p>一个简单的Atom feed如下所示：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">&lt;?xml</span> version="1.0" encoding="utf-8"<span class="kw">?&gt;</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">&lt;feed</span><span class="ot"> xmlns=</span><span class="st">"http://www.w3.org/2005/Atom"</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="co">&lt;!-- 以下是有关网站的全局描述 --&gt;</span></a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="kw">&lt;title&gt;</span>Ground Oddity<span class="kw">&lt;/title&gt;</span></a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="kw">&lt;link</span><span class="ot"> href=</span><span class="st">"http://jujuba.me/"</span><span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="kw">&lt;updated&gt;</span>2018-06-29T18:30:02Z<span class="kw">&lt;/updated&gt;</span></a>
<a class="sourceLine" id="cb12-8" title="8">  <span class="kw">&lt;author&gt;</span></a>
<a class="sourceLine" id="cb12-9" title="9">    <span class="kw">&lt;name&gt;</span>Jiahao Cai<span class="kw">&lt;/name&gt;</span></a>
<a class="sourceLine" id="cb12-10" title="10">  <span class="kw">&lt;/author&gt;</span></a>
<a class="sourceLine" id="cb12-11" title="11">  <span class="kw">&lt;updated&gt;</span>2018-06-29T22:06:42.669707+08:00<span class="kw">&lt;/updated&gt;</span></a>
<a class="sourceLine" id="cb12-12" title="12">  <span class="kw">&lt;id&gt;</span>http://jujuba.me/<span class="kw">&lt;/id&gt;</span></a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14">  <span class="co">&lt;!-- 以下是对entry的描述，一个entry代表博客中的一篇文章 --&gt;</span></a>
<a class="sourceLine" id="cb12-15" title="15">  <span class="kw">&lt;entry&gt;</span></a>
<a class="sourceLine" id="cb12-16" title="16">    <span class="kw">&lt;title&gt;</span>我如何手动管理我的博客<span class="kw">&lt;/title&gt;</span></a>
<a class="sourceLine" id="cb12-17" title="17">    <span class="kw">&lt;link</span><span class="ot"> href=</span><span class="st">"http://jujuba.me/posts/my-blog-management.html"</span><span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb12-18" title="18">    <span class="kw">&lt;id&gt;</span>http://jujuba.me/posts/my-blog-management.html<span class="kw">&lt;/id&gt;</span></a>
<a class="sourceLine" id="cb12-19" title="19">    <span class="kw">&lt;published&gt;</span>Apr 11, 2018<span class="kw">&lt;/published&gt;</span></a>
<a class="sourceLine" id="cb12-20" title="20">    <span class="kw">&lt;updated&gt;</span>2018-06-29T18:30:02Z<span class="kw">&lt;/updated&gt;</span></a>
<a class="sourceLine" id="cb12-21" title="21">    <span class="kw">&lt;summary&gt;</span>...<span class="kw">&lt;/summary&gt;</span></a>
<a class="sourceLine" id="cb12-22" title="22">  <span class="kw">&lt;/entry&gt;</span></a>
<a class="sourceLine" id="cb12-23" title="23"></a>
<a class="sourceLine" id="cb12-24" title="24"><span class="kw">&lt;/feed&gt;</span></a></code></pre></div>
<p>由于我的所有HTML文件都在同一文件夹下（posts/），所以我只需将该文件夹下的所有HTML文件都打开解析并提取我需要的内容即可。这里我写了个Python脚本来解决问题，主要使用BeautifulSoup这个库来解析一下HTML。</p>
<p>这里有个问题就是<code>published</code>和<code>updated</code>这两个选项如何获取的问题。在之前的设置中，我一直没有这个需求，所有文章中并未包含关于本文章的写作时间及最后一次更新时间等信息，直到现在要写RSS Feed才发现，这里我们可以通过改一下Pandoc的HTML的模板来解决这个问题，我的Pandoc模板文件位于<code>/usr/local/Cellar/pandoc/2.2.1/share/x86_64-osx-ghc-8.4.2/pandoc-2.2.1/data/templates/default.html5</code>，同时，也可以通过<code>pandoc -D html</code>来查看当前模板的内容。</p>
<p>打开之后，可以在该文件中添加如下自定义变量（自定义变量的使用可参考<a href="https://pandoc.org/MANUAL.html#using-variables-in-templates">此处</a>）：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb13-1" title="1">$if(last_modified)$</a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">"last_modified"</span><span class="ot"> content=</span><span class="st">"$last_modified$"</span> <span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3">$endif$</a>
<a class="sourceLine" id="cb13-4" title="4">$if(date)$</a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">"published"</span><span class="ot"> content=</span><span class="st">"$date$"</span> <span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb13-6" title="6">$endif$</a></code></pre></div>
<p>我们可以通过传入last_modified和date两个变量来控制生成的HTML，这两个变量不仅可以通过我们之前提到的YAML文件来传入，更可以通过Shell来传入，这就十分方便了。回顾之前写的Makefile，我们可以将FLAG改为：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">FLAG </span><span class="ch">=</span><span class="st"> --standalone --mathjax --metadata last_modified="`date +%FT%TZ`"</span></a></code></pre></div>
<p>这样一来，每次生成新的HTML文件时，Makefile就自动将临时生成的时间戳（如<code>2018-06-30T09:58:26Z</code>）传入文件，免去了手动配置之苦。</p>
<p>最后贴上我的RSS生成器代码：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1"><span class="co">#! /usr/bin/env python3</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="co"># -*- coding: utf-8</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="im">import</span> os</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="im">import</span> arrow</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7">path <span class="op">=</span> <span class="st">'./posts/'</span></a>
<a class="sourceLine" id="cb15-8" title="8">html_names <span class="op">=</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x[<span class="op">-</span><span class="dv">5</span>:] <span class="op">==</span> <span class="st">'.html'</span>, (os.listdir(path))))</a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10">rss_preamble <span class="op">=</span> <span class="st">"&lt;?xml version=</span><span class="ch">\"</span><span class="st">1.0</span><span class="ch">\"</span><span class="st"> encoding=</span><span class="ch">\"</span><span class="st">UTF-8</span><span class="ch">\"</span><span class="st"> ?&gt;"</span></a>
<a class="sourceLine" id="cb15-11" title="11"></a>
<a class="sourceLine" id="cb15-12" title="12">rss_head <span class="op">=</span> <span class="st">"""</span></a>
<a class="sourceLine" id="cb15-13" title="13"><span class="st">  &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;</span></a>
<a class="sourceLine" id="cb15-14" title="14"><span class="st">  &lt;title&gt;Ground Oddity&lt;/title&gt;</span></a>
<a class="sourceLine" id="cb15-15" title="15"><span class="st">  &lt;link href="http://jujuba.me/"/&gt;</span></a>
<a class="sourceLine" id="cb15-16" title="16"><span class="st">  &lt;link href="http://jujuba.me/feed.xml" rel="self"/&gt;</span></a>
<a class="sourceLine" id="cb15-17" title="17"><span class="st">  &lt;id&gt;http://jujuba.me/&lt;/id&gt;</span></a>
<a class="sourceLine" id="cb15-18" title="18"><span class="st">"""</span></a>
<a class="sourceLine" id="cb15-19" title="19">rss_head <span class="op">+=</span> <span class="st">"&lt;updated&gt;"</span> <span class="op">+</span> <span class="bu">str</span>(arrow.now()) <span class="op">+</span> <span class="st">"&lt;/updated&gt;</span><span class="ch">\n</span><span class="st">"</span></a>
<a class="sourceLine" id="cb15-20" title="20"></a>
<a class="sourceLine" id="cb15-21" title="21">rss_tail <span class="op">=</span> <span class="st">'&lt;/feed&gt;'</span></a>
<a class="sourceLine" id="cb15-22" title="22">rss_body <span class="op">=</span> <span class="st">''</span></a>
<a class="sourceLine" id="cb15-23" title="23"></a>
<a class="sourceLine" id="cb15-24" title="24"><span class="cf">try</span>: </a>
<a class="sourceLine" id="cb15-25" title="25">    <span class="im">from</span> BeautifulSoup <span class="im">import</span> BeautifulSoup</a>
<a class="sourceLine" id="cb15-26" title="26"><span class="cf">except</span> <span class="pp">ImportError</span>:</a>
<a class="sourceLine" id="cb15-27" title="27">    <span class="im">from</span> bs4 <span class="im">import</span> BeautifulSoup</a>
<a class="sourceLine" id="cb15-28" title="28"></a>
<a class="sourceLine" id="cb15-29" title="29"><span class="cf">for</span> html_name <span class="kw">in</span> html_names:</a>
<a class="sourceLine" id="cb15-30" title="30">  <span class="cf">with</span> <span class="bu">open</span>(path <span class="op">+</span> html_name, <span class="st">'r'</span>) <span class="im">as</span> html:</a>
<a class="sourceLine" id="cb15-31" title="31">    parsed_html <span class="op">=</span> BeautifulSoup(html.read().encode(<span class="st">'utf-8'</span>), <span class="st">"html5lib"</span>)</a>
<a class="sourceLine" id="cb15-32" title="32">  rss_body <span class="op">+=</span> <span class="st">'&lt;entry&gt;'</span></a>
<a class="sourceLine" id="cb15-33" title="33">  title <span class="op">=</span> parsed_html.body.find(<span class="st">'h1'</span>, attrs<span class="op">=</span>{<span class="st">'class'</span>:<span class="st">'title'</span>}).text</a>
<a class="sourceLine" id="cb15-34" title="34">  rss_body <span class="op">+=</span> <span class="st">'&lt;title&gt;'</span> <span class="op">+</span> title <span class="op">+</span> <span class="st">'&lt;/title&gt;'</span></a>
<a class="sourceLine" id="cb15-35" title="35"></a>
<a class="sourceLine" id="cb15-36" title="36">  published <span class="op">=</span> parsed_html.find(<span class="st">'meta'</span>, attrs<span class="op">=</span>{<span class="st">'name'</span>:<span class="st">"published"</span>}).get(<span class="st">"content"</span>)</a>
<a class="sourceLine" id="cb15-37" title="37">  rss_body <span class="op">+=</span> <span class="st">'&lt;published&gt;'</span> <span class="op">+</span> published <span class="op">+</span> <span class="st">'&lt;/published&gt;'</span></a>
<a class="sourceLine" id="cb15-38" title="38"></a>
<a class="sourceLine" id="cb15-39" title="39">  updated <span class="op">=</span> parsed_html.find(<span class="st">'meta'</span>, attrs<span class="op">=</span>{<span class="st">'name'</span>:<span class="st">"last_modified"</span>}).get(<span class="st">"content"</span>)</a>
<a class="sourceLine" id="cb15-40" title="40">  rss_body <span class="op">+=</span> <span class="st">'&lt;updated&gt;'</span> <span class="op">+</span> updated <span class="op">+</span> <span class="st">'&lt;/updated&gt;'</span></a>
<a class="sourceLine" id="cb15-41" title="41"></a>
<a class="sourceLine" id="cb15-42" title="42">  url <span class="op">=</span> <span class="st">'http://jujuba.me/posts/'</span> <span class="op">+</span> html_name</a>
<a class="sourceLine" id="cb15-43" title="43">  rss_body <span class="op">+=</span> <span class="st">'&lt;link href="'</span> <span class="op">+</span> url <span class="op">+</span> <span class="st">'"/&gt;'</span></a>
<a class="sourceLine" id="cb15-44" title="44">  rss_body <span class="op">+=</span> <span class="st">'&lt;id&gt;'</span> <span class="op">+</span> url <span class="op">+</span> <span class="st">'&lt;/id&gt;'</span></a>
<a class="sourceLine" id="cb15-45" title="45">  rss_body <span class="op">+=</span> <span class="st">'&lt;author&gt; &lt;name&gt;Jiahao Cai&lt;/name&gt; &lt;/author&gt;'</span></a>
<a class="sourceLine" id="cb15-46" title="46"></a>
<a class="sourceLine" id="cb15-47" title="47">  contents <span class="op">=</span> <span class="bu">str</span>(parsed_html.body).replace(<span class="st">'&lt;body&gt;'</span>, <span class="st">''</span>).replace(<span class="st">'&lt;/body&gt;'</span>, <span class="st">''</span>)</a>
<a class="sourceLine" id="cb15-48" title="48">  rss_body <span class="op">+=</span> <span class="st">'&lt;summary type="html"&gt;'</span> <span class="op">+</span> <span class="st">'&lt;![CDATA[ '</span> <span class="op">+</span> contents[<span class="dv">0</span>:<span class="dv">500</span>] <span class="op">+</span> <span class="st">' ]]&gt;'</span> <span class="op">+</span> <span class="st">'&lt;/summary&gt;'</span></a>
<a class="sourceLine" id="cb15-49" title="49">  rss_body <span class="op">+=</span> <span class="st">'&lt;content type="html"&gt;'</span> <span class="op">+</span> <span class="st">'&lt;![CDATA[ '</span> <span class="op">+</span> contents <span class="op">+</span> <span class="st">' ]]&gt;'</span> <span class="op">+</span> <span class="st">'&lt;/content&gt;'</span></a>
<a class="sourceLine" id="cb15-50" title="50">  rss_body <span class="op">+=</span> <span class="st">'&lt;/entry&gt;'</span></a>
<a class="sourceLine" id="cb15-51" title="51"></a>
<a class="sourceLine" id="cb15-52" title="52"></a>
<a class="sourceLine" id="cb15-53" title="53"><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'atom.xml'</span>, <span class="st">'w'</span>) <span class="im">as</span> feed:</a>
<a class="sourceLine" id="cb15-54" title="54">  feed.write(rss_preamble)</a>
<a class="sourceLine" id="cb15-55" title="55">  feed.write(rss_head)</a>
<a class="sourceLine" id="cb15-56" title="56">  feed.write(rss_body)</a>
<a class="sourceLine" id="cb15-57" title="57">  feed.write(rss_tail)</a></code></pre></div>
<p><a name="sync"></a></p>
<h2 id="synchronize">5. Synchronize</h2>
<p>这些都解决了之后，要将博客文件传送到服务器上，怎么传送是个问题。如果每次都将全部文件重新传一遍，肯定是太慢了，特别从国内往国外服务器传文件的时候，根本受不了，这里我使用<a href="https://en.wikipedia.org/wiki/Rsync">rsync</a>这个工具来传送文件。rsync会在传输之前将服务器端的文件与本地文件做一个对比，然后只传输被修改过的文件，不仅如此，rsync还可以使用<code>-z</code>参数将文件在传输过程中打包，大大提高了传输速度。</p>
<p>在Makefile中增加以下内容：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode makefile"><code class="sourceCode makefile"><a class="sourceLine" id="cb16-1" title="1"><span class="dv">sync:</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="ch">@</span><span class="fu">rsync -avz ~/blog/ username@127.0.0.1:/var/www/html</span></a></code></pre></div>
<p>接下来就可以直接通过<code>make sync</code>来将我的博客同步到服务器端了。</p>
<hr/>
<p>Update:<br/>
我把我的博客开源了，你可以在<a href="https://github.com/jiahao42/blog">这里</a>找到它。</p>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>近况</title><published>Mar 09, 2019</published><updated>2020-03-06T11:20:42Z</updated><link href="http://jujuba.me/posts/2019-march.html"/><id>http://jujuba.me/posts/2019-march.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">近况</h1>
<p class="date">Mar 09, 2019</p>
</header>
<p><img alt="PhD vs Marriage" height="450" src="../imgs/phd-vs-marriage.gif"/></p>
<p>很久没写东西了，因为实在太空了，也因为实在太忙了。</p>
<p>从2018 fall的第一学期说起吧，那个时候算是太空了。上了master之后，我发现我们学校的cs master真的很简单，workload不是很大，然后老师给分也很仁慈。我就有点迷失自己，除了写下作业搞点研究之外就是天天打打炉石刷刷题，但是我其实对刷题没兴趣，所以打炉石更多一点 :)</p>
<p>读cs master的一个初衷当然就是在美帝找工作了，但是很搞笑的是，我的简历，我自认为还行，却被大公司拒了个遍，一整个学期下来，投了大概四五十个公司吧，马马虎虎地做烂了很多个oa，最后就电面了两个，有个还挂在HR面，因为我说不出来他们公司到底是干啥的… 当然我也很不喜欢找工作的体验，总感觉过简历在拼运气，而显然我的运气并不太好，总之找实习挺失败的就是了。</p>
<p>好吧就在这个时候，我跟着做research的教授，新来的，非常着急地在招学生，然后他又非常想拉我当他的phd，还老是出去请我吃饭，甚至跟我说you can transfer to phd anytime you want，说得我都不好意思了。当然我也挺想读他的phd，虽然他自己也刚phd毕业，但是我们的方向很match，而且我也觉得他挺厉害的。在第一个学期考完期末考之后，我依然没有找到实习，这时候我的感觉，说好听点，我觉得冥冥之中我注定要试一试读phd，说难听点，读phd是我那时候的最优解。然后我就毅然提交了转phd申请。大约一个月吧，申请就approve了，我读了一学期master之后，就转成了phd。</p>
<p>嗯，现在我承认我还没有准备好读phd。经济独立，phd头衔，本科直博，还可以顺便拿个master学位… 这些bonus在当时的我眼里变成了很重要的东西…</p>
<p>然后就是现在了，正式phd的第一个学期，跟ms完全不同的感受，对我来说如果说ms的难度是5的话，phd的难度大概是50吧… 这学期的难度就突然到了另一个level，导师好像把我想得太厉害了，分给我一个很复杂的project。硬着头皮做了2个多月，最后实在搞不下去就先搁浅了。然后上个星期换了个新project，不过现在已经3月了，而我们的目标依然是在学期结束前发出一篇顶会paper，只剩两个月不到了… 总之我现在就很忙很忙，今天春假开始了，但是我坐在家里一天没有出门，憋着写代码，跟导师交流，感觉时刻要爆炸。倒不是代码不会写，这点我还是很自信的，只不过我的domain background确实差了点，他跟我描述的project细节我都想不清楚，经常误解。唉，毕竟我只是个刚本科毕业，连公司实习都从没去过的愣头青罢了。</p>
<p>更惨的是，我是我导师的第一个学生，平时遇到问题了也没人问，只能直接问导师，终于有一天（其实就是今天），我把导师问烦了… 看看隔壁实验室八九个phd，层次分明，不禁还是有点羡慕。想到下学期有新人要来，感觉自己的水平实在有点堪忧，不过也无所谓，新人水平比我好可以多个人问问，水平比我差也可以一起自闭。不过还好我回到家里，家里还有个在一起很多很多年的女朋友，虽然我们俩的专业南辕北辙，很多技术上的事没法找她讨论，但是坐在一起的感觉可以稍微让我好受点。</p>
<p>最后，我也必须承认我之前膨胀了，感觉ms太简单，以为phd也不过如此，也许只需多花点时间罢了，但是现在看来真不是这样，phd真的是一场艰苦的修行，而我才刚刚开始罢了。之前在瑞典的时候，教授们都会主动说不要叫他们professor，我就把这个习惯带到了美国，我导师让我别老是对别人直呼其名，因为很多人不喜欢这样。我心里还想，为啥美国的教授这么矫情，我以后拿了phd就希望人家直接叫我名字。现在我渐渐理解了，phd is not just a title, it means a lot…</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>关于[乔布斯, 费曼]言论的一些摘录</title><published>Mar 31, 2018</published><updated>2020-03-06T11:20:43Z</updated><link href="http://jujuba.me/posts/quote_from_jobs.html"/><id>http://jujuba.me/posts/quote_from_jobs.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">关于[乔布斯, 费曼]言论的一些摘录</h1>
<p class="date">Mar 31, 2018</p>
</header>
<ul>
<li><a href="#overview">0. Overview</a></li>
<li><a href="#jobs">1. Steve Jobs</a>
<ul>
<li><a href="#the_lost_interview">1.1 The Lost Interview</a></li>
</ul></li>
<li><a href="#feynman">2. Richard Feynman</a>
<ul>
<li><a href="#mr.feynman">2.1 The Fantastic Mr. Feynman</a></li>
<li><a href="#magnets">2.2 Feynman: Magnets FUN TO IMAGINE 4</a></li>
</ul></li>
</ul>
<p><a name="overview"></a></p>
<h2 id="overview">0. Overview</h2>
<p>仅以此记录这两个我所欣赏的人的部分言论。</p>
<p><a name="jobs"></a></p>
<h2 id="steve-jobs">1. Steve Jobs</h2>
<p>说起来我也用了很多年的Apple产品了（限于iPhone，MacBook Pro），但对乔布斯的了解甚少。当我还是大一的时候，我表哥送给我一本乔布斯传，我很庆幸直到今天我连那本书的外面的塑料薄膜都没撕开。因为在随后的几年中，我意识到一手资料的重要性，要学习知识，最好要直接寻找知识的源头，而不是去学习经过他人转述的二手知识。了解这个知识是为了解决什么问题而存在，是在何种状态下而被创造其实是很重要的，其重要性不亚于知识本身，这也是我为什么觉得中学就该好好教历史，当然我说的是数学史、物理学史、化学史等，而不是什么党史 :) 想要了解一个人也是一样的，看传记中的评价永远比不上看这个人本身的言论，每个人应当有自己的思考，给出自己的评价。<br/>
鉴于乔布斯生平的很多fact都能在互联网上能找到，我决定着重记录视频中出现的opinion，而非fact。</p>
<p><a name="the_lost_interview"></a></p>
<p><img alt="steve_jobs" src="../imgs/jobs.jpg" style="height: 300px;"/></p>
<h3 id="the-lost-interview">1.1 <a href="https://www.youtube.com/watch?v=TRZAJY23xio">The Lost Interview</a></h3>
<p>这篇采访之所以叫The Lost Interview，是因为先前大家都认为这篇采访的母带在从伦敦运往美国的途中丢失了。不过后来，这个系列的Director，Paul，在自己家的车库里发现了一份VHS Copy，于是我们终于能看到这篇采访，感谢Paul。</p>
<p><strong>背景：</strong> 这篇采访发生在1995，十年前（1985），<a href="https://zh.wikipedia.org/wiki/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF#%E5%89%B5%E6%A5%AD">乔布斯被Apple开除</a>，此时的他正在管理NeXT，一家在他离开Apple之后建立的公司。有趣的是，在采访结束后的一年（1996），Apple收购了NeXT，乔布斯也最终回到了Apple。</p>
<p>主持人问乔布斯是怎么学会管理一家公司的：</p>
<blockquote>
<p>在管理公司的这些年里，我发现了一些事，我总是会问别人为什么要做这些事，得到的回答却总是，“（想完成这个目标）就是需要做这些事的”，没人知道他们自己为什么要这样做，没人去深层次地对这些事进行思考。举个例子，在车库开发Apple I的时候，我们很清楚的知道这个产品的支出；当我们在工厂里开发Apple II的时候，会计部门想要计算标准支出，就是你设置一个标准支出，然后在季度结束的时候，你就可以根据实际支出去计算差值，我一直在问为什么要这么做，答案却是“事情就是这么做的”。大概六个月之后，我终于搞清楚了这是个什么东西，人们使用这个东西只是因为他们不能很好地预估自己的支出，所以他们给出一个支出的预估值，并在季度结束时修正自己的预估值，而这只是因为他们的信息系统不够好罢了，（人们应该摆脱这些东西）可是没人这么做过。当我们在开发Macintosh的时候，我们摒弃了这些陈旧的概念，因为我们很清楚地知道我们的支出。在商业中，我把很多东西叫做过时的传统（folklore），他们现在这么做只是因为他们从前是这么做的。所以只要你愿意去发现问题，并深入思考，你可以很快地学习商业管理，这并不是什么难事（rocket science）。</p>
</blockquote>
<p>主持人问到编程相关的问题：</p>
<blockquote>
<p>…我们那时写的程序跟实用这个词搭不上边，它们更像是一面反映了你的思考过程的镜子，我觉得编程最重要的价值就是学习如何思考。我认为这个国家的每个人都应该学习编程，学习一门编程语言，因为编程会教你如何思考，就像去一所法律学校就读一样，我并不认为每个人都应该成为一名律师，但是我认为学习法律是非常有用的，因为它教会你用一种特定的方式思考。同样的，编程也会教会你一种略微不同的思考方式，所以我把计算机科学看作是文科（liberal art），它应该是每个人都要学习的东西。</p>
</blockquote>
<p>主持人问到为什么乔布斯说“The technology crashed and burned in Xeror”：</p>
<blockquote>
<p>…John Sculley来自百事公司（PepsiCo），他也许每十年才推出一个新产品，而且“新产品”也许只是换了个大小不同的瓶子而已。如果你是个做产品的人（product person），你能做的非常有限，因为你不能经常改变公司的路线，所以谁决定了公司的成败呢？是市场销售人员。所以他们才是会升职加薪的人，他们才是会管理公司的人。对百事公司来说，这也许是ok的，但同样的事也会在科技公司发生，特别是那些获得了市场垄断的公司，如IBM和施乐(Xeror)。如果你是个在IBM或施乐做产品的人，你可以做出更好的产品，so what？当公司垄断了市场的时候，它就已经不再成功了。能让这个公司（看起来）更加成功的只能是市场销售人员，最后他们会掌管这个公司，做产品的人会被排除出决策层，这家公司也就遗忘了如何才能做出伟大的产品。那些一开始将公司带向成功的，对于产品的鉴赏力以及才能，最终被一群对产品好坏一无所知的人给毁坏了。他们不懂一个好的idea最终变成一个好的product需要什么样的过程，他们的心中也没有真正想要去帮助顾客解决问题的欲望。</p>
</blockquote>
<p>当提到乔布斯想要将开发重点放在GUI上的时候，却遭到了一大堆人的反对：</p>
<blockquote>
<p>…当公司渐渐成长的时候，大多数公司会想要复制他们一开始的成功方式，他们觉得成功的关键就藏在他们成功的过程中（也许他们并不知道究竟是过程中的哪个点促成了他们的成功），所以他们开始尝试在整个公司中将这一成功的过程给制度化（institutionalize）。用不了多久，大家就会开始将这个过程（process）误认为是产品的内涵（content），这就是IBM衰落的原因。IBM拥有世界上最好的管理过程的人才（process people），但是他们忘记了产品的内涵。这件事也在Apple内部有些许端倪，我们拥有很多很棒的管理型人才，可他们就是对产品的内涵一无所知。在我的生涯里，我发现最好的人才是真正理解产品内涵的人，他们非常非常难以管理，但是你要忍受这些，因为他们是如此理解产品的内涵。这就是做成伟大产品的关键，不是管理过程，而是产品的内涵。</p>
</blockquote>
<p>主持人问到“在开发产品的过程中什么最重要”：</p>
<blockquote>
<p>…这种病就是以为有一个好的想法就已经完成了90%的工作，如果你告诉其他人“我有一个好的想法”，他们就一定能完成这个想法。这种病的问题在于，在伟大的想法与伟大的产品之间，有着一条鸿沟。最初的想法会在实现的过程中不断改变并进步，最后被实现了的想法绝对不会和最初的想法是一模一样的，因为在这个过程中你学到了更多的东西，你明白了其中的微妙之处，你意识到了你必须做无数的妥协去实现你的想法。就比如你必须向材料的物理性质妥协，比如电子的性质，塑料的性质或者玻璃的性质。设计产品就好像放了5000个概念在你的大脑里，然后把它们用新式的不同的方式组合在一起，最终才能得到你想要的东西。每天你都能发现新的东西，新的问题或者新的机遇，从而能将这些概念更好地组合在一起，这个过程才是最重要的。</p>
</blockquote>
<p>乔布斯谈到招募人才的重要性：</p>
<blockquote>
<p>当你费尽心思找到了足够多的人才(A player)时，你会发现他们真的能够很好的互相合作，因为他们之前从来没有得到过这样的机会（与这么多优秀的人一起共事）。他们也不会想要和水平不够的人共事(B and C player)，于是就会形成一种自我监督，他们只会招募更多的人才。招募一些好的人才，然后这种情况就会在公司中传播，最后公司里就会充满了好的人才，这就是Mac团队的样子。</p>
</blockquote>
<p>主持人问到乔布斯你怎么知道哪个才是正确的方向：</p>
<blockquote>
<p>You know, 这最终取决于品味（taste），取决于你要挖掘人类最好的那些东西，然后尝试着将这些好东西放到你正在做的产品里面。毕加索说过<a href="https://www.zhihu.com/question/19847983/answer/13146602">能工摹形，巧匠窃意</a>（good artists copy, great artists steal），而我们总是在“无耻”地偷窃伟大的想法。我认为Macintosh之所以伟大的一部分原因在于，开发Macintosh的人是音乐家们、诗人们、艺术家们、动物学家们和历史学家们，他们又碰巧是世界上最好的计算机科学家，如果这些人不从事计算机科学，他们就会去做其他领域的美好的事情。我们努力想要将我们在其他领域看到的最好的东西放进这个领域里，如果你的眼光非常狭窄，我不认为你能做到这一步。</p>
</blockquote>
<p><a name="feynman"></a></p>
<h2 id="richard-feynman">2. <a href="https://en.wikipedia.org/wiki/Richard_Feynman">Richard Feynman</a></h2>
<p><a name="mr.feynman"></a></p>
<p><img alt="mr.feynman" src="../imgs/mr.feynman.jpg" style="height: 300px;"/></p>
<h3 id="the-fantastic-mr.-feynman">2.1 <a href="https://www.youtube.com/watch?v=LyqleIxXTpw">The Fantastic Mr. Feynman</a></h3>
<p>Feynman的父亲在一家生产制服的工厂工作，长期与军队的接触使他对于权威有着强烈的抗拒，而他也将这种价值观深深印在了Feynman的心里：</p>
<blockquote>
<p>Disrespect是我的父亲教给我的众多东西之一。他翻到New York Times上的一张图片，图片上也许是个什么将军，他就会说“看看这些人类吧”，他说，“这个人就站在这里，而其他人都在向他鞠躬。他们有什么区别？为什么其他人都要向他鞠躬？只是因为他的名字与他的地位罢了，因为他身穿的制服，而并不是因为他做了什么了不得的事情。”</p>
</blockquote>
<p>对方问Feynman，“你觉得你的工作值得一个诺奖吗？”，Feynman对此的回答：</p>
<blockquote>
<p>“我不知道，我不知道关于诺贝尔奖的任何事，我不明白这一切都是怎么回事，什么值得不值得，如果瑞典学院（Swedish Academy）决定X，Y和Z获得了诺贝尔奖，那就获得了吧。瑞典学院的那些人认为这个成果足够优秀，优秀到可以拿一个奖，而我却根本看不到这有什么意义。我已经拿到了我的奖励了，那就是探索事物所获得的满足感。这个突破性的发现，以及它被广泛使用的事实，这些才是真实的东西。荣誉对我来说都是不真实的，我不相信所谓荣誉。它让我感到烦扰，荣誉对我来说是个麻烦。荣誉就是肩章，荣誉就是制服，我的父亲从小到大就是这么告诉我的。我根本无法忍受它，荣誉会伤害我。”</p>
</blockquote>
<p>Feynman说到科学之美：</p>
<blockquote>
<p>“我有个朋友是艺术家，他有一个我无法同意的观点。他拿着一朵花说，看这朵花多么美丽，我当然会同意这个观点。他说他作为一个艺术家，他可以看到这朵花是多么得美丽，可是你作为一个科学家，你只会把这朵花给拆解成不同的部分，于是它就成为了一朵无趣的花，我觉得他这个观点有点不正常。首先，他所看到的花朵的美丽对其他所有人都是可见的，我相信这当然也包括我，尽管我没有他那么训练有素，我也可以欣赏到这朵花的美丽之处。与此同时，我在这朵花上看到的东西比他看到的更多，我可以想象这朵花拥有灵魂，它会做很多复杂的动作，这些东西也有它们自己的美感。也就是说，（我能欣赏到的）不只是在这个厘米维度下的美，在更小的维度上，那里也有另一种美，它的内部结构，它的生长过程，它改变颜色来吸引昆虫来为它传粉的有趣事实，这说明昆虫也可以看到色彩。这就引出了另一个问题，那些比我们低等的生物，它们有没有美感呢？它们如何判断什么是美呢？这些所有由科学知识所引出的有趣问题，为花朵增添了一种神秘的令人兴奋的氛围，我不明白这些科学知识怎么会减少我所见到的美。”</p>
</blockquote>
<p><a name="magnets"></a></p>
<p><img alt="mr.feynman" src="../imgs/feynman_magnets.jpg" style="height: 300px;"/></p>
<h3 id="feynman-magnets-fun-to-imagine-4">2.2 <a href="https://www.youtube.com/watch?v=wMFPe-DwULM">Feynman: Magnets FUN TO IMAGINE 4</a></h3>
<p>这个视频从有人问了Feynman一个问题开始：</p>
<blockquote>
<p>“如果你拿着两块磁铁并试着将它们推到一起，你可以感觉到它们之间的推力，如果将一块磁铁换到另一个方向的话，它们就会吸到一起。那么，这两块磁铁之间的感觉是什么样的呢？”</p>
</blockquote>
<blockquote>
<p>“什么叫这两块磁铁之间的感觉？”</p>
</blockquote>
<blockquote>
<p>“这两块磁铁之间存在一些东西不是吗？当我将两块磁铁推到一起时，我能感觉到它们之间有一些东西。”</p>
</blockquote>
<blockquote>
<p>“认真听我的问题，当你说‘这两块磁铁之间的感觉’时，你到底想表达什么呢？它们之间当然有一种感觉，可是你想知道关于它们的什么呢？”</p>
</blockquote>
<blockquote>
<p>“我想知道这两个金属块之间到底发生了什么。”</p>
</blockquote>
<blockquote>
<p>“它们互相排斥。”</p>
</blockquote>
<blockquote>
<p>“什么叫它们之间互相排斥？它们之间为什么要互相排斥？它们是怎么互相排斥的？我必须得说我觉得这是个非常非常合理的问题。”</p>
</blockquote>
<blockquote>
<p>“这当然是个合理的问题，而且还是个很棒的问题。我们来看你的问题，当你问为什么某些事会发生，一般人会如何回答为什么这件事会发生？比如说，Aunt Minnie进医院了，为什么？因为她在冰上滑倒了并且摔坏了她的髋骨，这个解释会让人们满意。但是这个解释无法让某些来自另一个星球的，对人类一无所知的人满意。<br/>
首先，你应该明白为什么当你摔坏髋骨的时候你要去医院，当你的髋骨摔坏了之后你怎么去医院，因为她的丈夫看到了她的髋骨摔坏了然后打电话给医院，医院派人过来，这些前提都是能够被人类所理解的。当你试着去解释一个为什么的问题时，你需要在某个体系之下去解释，在这个体系下我们必须允许一些条件为真，否则你就会无休止地询问为什么。为什么她的丈夫要打电话给医院，因为她的丈夫对她妻子很关心，但这也不是绝对的，有些丈夫就对他们的妻子不感兴趣，他们可能总是喝醉，总是很愤怒。<br/>
这样思考的话，你就会得到对于这个世界的非常有趣的理解，包括事物之间的复杂关联。如果你持续分析某件事，你就会从各个不同的角度越来越深入地去看待这件事。比方说你开始怀疑，为什么Aunt Minnie在冰上摔倒了，因为冰是很光滑的，大家都知道这一点，没问题。但是为什么冰是光滑的呢，这就有点使人好奇了，冰是非常非常光滑的，你就开始想为什么会这样呢。我告诉了你冰是非常光滑的，这就解释了Aunt Minnie为什么摔倒，你可以对你的这个回答感到满意，但是你也可以继续好奇，为什么冰是光滑的呢？这时候你就会牵扯到一些其他东西了，因为世界上并没有那么多东西可以跟冰一样光滑。你很难得到这种光滑的东西，就算得到了，也八成是一种湿乎乎的黏滑的东西，可是冰却是一种如此光滑的固体，这就很奇怪了。这是因为当你站在一块冰上的时候，在那个短暂的瞬间里，冰与人之间的接触面会被挤压并融化，所以这就相当于在那个瞬间，你在一个由水组成的表面上滑行。为什么这只发生在冰上却不发生在其他东西上？因为当水结成冰时，水是会膨胀的，而当人站在上面时，冰所受的挤压会逆转这个膨胀的过程，从而使之融化，但是其他东西在结冰时就只会产生裂缝，当你用力挤压的时候，它们依然是固体。那为什么只有水在结冰的时候会膨胀而其他东西不会？<br/>
我并没有在回答你的问题，但是我在试着告诉你一个为什么的问题是多么地难以回答，你必须要知道哪些东西是允许被你理解的，允许被你知道的，以及哪些不是的。你应该会注意到，在上面那个例子里，每当我问了一个为什么，我们就会发现更加深层次的，同时也更加有趣的东西。我们甚至可以再深入一点，为什么Aunt Minnie滑倒了就会摔倒呢，这就跟每个星球上的重力有关了，当然这还与其他的一些东西有关。不过我们先不管这些了，我们只要知道这个深入的过程是非常漫长的。<br/>
回到你的例子，当你问我，为什么两块磁铁会互相排斥，我的回答会有很多很多不同的层次，这取决于你是一个物理系的学生，或是一个对物理一无所知的人。如果是一个对物理一无所知的人问我，我就只能说，磁铁之间存在的磁力使它们互相排斥，你可以感受到它们的排斥。你可能会觉得很奇怪，因为你从来没有见过其他的力跟这所谓的磁力一样，当你将一块磁铁反向时，磁铁又变得互相吸引了。世界上存在着另一种相似的力叫做电力（electric force），它也面临这同样的问题，你会发现电力也是十分诡异的。可是你却能够接受以下事实：当你的手用力按压一把椅子的时候，你会感受到这把椅子正在用相同的力推你。但是我们根据观察发现，这是和磁力是类似的，电力的互斥（electrical repulsion）会阻止你的手穿过椅子，因为在微观层面存在着电力。事实证明，我一开始所希望解释的电力与磁力各自的互斥问题，最终是一个更深层次的东西，而这个更深层次的东西，又可以用来解释很多人们不知不觉就接受了的事实，比如大家都知道我们不能将我们的手穿过这把椅子，大家都觉得这是理所当然的。但是如果你问，为什么人不能把自己的手穿过椅子呢？这就会牵扯到上面提到过的互斥力了。这时候我们又会开始好奇，为什么磁力的作用距离比其他的力大这么多呢？这就跟一个事实有关，那就是在金属中，所有的电子都朝着同一个方向转动并形成直线，它们的力会被叠加直到大到你可以感受到这个力的存在…<br/>
我无法用一些你熟悉的东西去解释异性相吸的问题，如果我说两块磁铁之间的互相吸引就好像是它们之间被橡胶带给连在一起了，那我就是在欺骗你，因为它们根本不是由橡胶带相连的，我不该陷入这种麻烦，因为你马上就会接着问我橡胶带的本质是什么。其次，如果你足够好奇的话，你又会问我，为什么橡胶带会倾向于恢复原样，我最后又要用电力来解释它，而电力正是我想要利用橡胶带来解释的东西，那我就不只是在欺骗你了，我还欺骗得非常蹩脚。所以，我并不能告诉你为什么两块磁铁会互相吸引，我只能告诉你，它们就是互相吸引，这是各种不同的力的一个特性，包括电力，磁力，重力等，它们就这个世界的一部分。如果你是个物理系的学生，我就会告诉你电力和磁力存在着某种非常紧密的关联，而重力和电力之间的关系目前还不清楚，等等。我真的不能够做到用某种你更熟悉的事物来解释磁力，因为我不理解如何用你更熟悉的事物来解释它。</p>
</blockquote>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>代码的taste</title><published>Aug 10, 2018</published><updated>2020-03-06T11:20:44Z</updated><link href="http://jujuba.me/posts/taste-of-code.html"/><id>http://jujuba.me/posts/taste-of-code.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">代码的taste</h1>
<p class="date">Aug 10, 2018</p>
</header>
<p><img alt="Linus on TED" height="250" src="../imgs/linus-on-TED.png"/></p>
<p>今天在YouTube上看了<a href="https://www.youtube.com/watch?v=o8NPllzkFhE">Linus Torvalds的一场TED</a>，Linus拿了一小段代码来说明代码的taste问题。</p>
<p>代码很简单，就是在一个单向链表里删除一个指定节点，一般学校里教的写法都是像下面这样的：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">void</span> remove_list_entry(linked_list* entry) {</a>
<a class="sourceLine" id="cb1-2" title="2">    linked_list* prev = NULL;</a>
<a class="sourceLine" id="cb1-3" title="3">    linked_list* walk = head;</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="co">//Walk the list </span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="cf">while</span> (walk != entry) {</a>
<a class="sourceLine" id="cb1-7" title="7">        prev = walk;</a>
<a class="sourceLine" id="cb1-8" title="8">        walk = walk-&gt;next;</a>
<a class="sourceLine" id="cb1-9" title="9">    }</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="co">// Remove the entry by updating the</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="co">// head or the previous entry</span></a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="cf">if</span> (!prev) {</a>
<a class="sourceLine" id="cb1-14" title="14">        head = entry-&gt;next;</a>
<a class="sourceLine" id="cb1-15" title="15">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-16" title="16">        prev-&gt;next = entry-&gt;next;</a>
<a class="sourceLine" id="cb1-17" title="17">    }</a>
<a class="sourceLine" id="cb1-18" title="18">}</a></code></pre></div>
<p>值得注意的是，在代码的结尾有一个if statement，这是用来区分两种情况的：</p>
<ul>
<li>被删除的节点是这个单向链表的<code>head</code>，此时我们需要一个新的<code>head</code>，</li>
<li>被删除的节点不是这个单向链表的第一个节点，此时我们只需将被删除节点的前置节点的next指针指向被删除节点的后置节点即可。</li>
</ul>
<p>但是Linus认为这种写法是缺少taste的，他更喜欢下面的这种写法：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> remove_list_entry(linked_list* entry) {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co">// The "indirect" pointer points to the</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="co">// *address* of the thing we'll update</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">    linked_list** indirect = &amp;head;</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="co">// Walk the list, looking for the thing that</span></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="co">// points to the entry we want to remove</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="cf">while</span> ((*indirect) != entry)</a>
<a class="sourceLine" id="cb2-11" title="11">        indirect = &amp;(*indirect)-&gt;next;</a>
<a class="sourceLine" id="cb2-12" title="12">        </a>
<a class="sourceLine" id="cb2-13" title="13">    <span class="co">// .. and just remove it</span></a>
<a class="sourceLine" id="cb2-14" title="14">    *indirect = entry-&gt;next;</a>
<a class="sourceLine" id="cb2-15" title="15">}</a></code></pre></div>
<p>与上面的写法不同，这里我们直接将需要被删除节点的后置节点的next地址复制到被删除节点的前置节点的next指针上，无需考虑被删除节点是否是<code>head</code>这个问题，从而也省去了第一段代码中的if statement，这毫无疑问是更加方便的做法。</p>
<p>下面说一下第二段代码的原理。</p>
<p>首先下面的是我们这里用到的<code>linked_list</code>的定义，普通的链表节点：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> Node {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="dt">int</span> data;</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">struct</span> Node *next;</a>
<a class="sourceLine" id="cb3-4" title="4">} linked_list;</a></code></pre></div>
<!-- 假设此时我们的链表中有5个节点，其内容分别是1/2/3/4/5，有一`head`指针指向`head`，我们希望删除节点2。 -->
<p>假设此时我们的链表中有5个节点，其内容分别是1/2/3/4/5，我们希望删除节点3。</p>
<pre class="text"><code>       head                       entry -+
        |                           |
    +-------+     +-------+     +-------+     +-------+     +--------+
    | 1 |   |----&gt;| 2 |   |----&gt;| 3 |   |----&gt;| 4 |   |----&gt;| 5 |NULL|
    +-------+     +-------+     +-------+     +-------+     +--------+</code></pre>
<p><code>linked_list** indirect = &amp;head;</code>这一行代码将会构造一个指向<code>head</code>指针的二级指针：</p>
<pre class="text"><code>       head                      entry -+
        |                           |
    +-------+     +-------+     +-------+     +-------+     +--------+
    | 1 |   |----&gt;| 2 |   |----&gt;| 3 |   |----&gt;| 4 |   |----&gt;| 5 |NULL|
    +-------+     +-------+     +-------+     +-------+     +--------+
        ^
        |
      +---+
      |   |
      +---+
     indirect</code></pre>
<p>接下来是一个<code>while loop</code></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="cf">while</span> ((*indirect) != entry)</a>
<a class="sourceLine" id="cb6-2" title="2">  indirect = &amp;(*indirect)-&gt;next;</a></code></pre></div>
<p>首先我们解读<code>(*indirect) != entry</code>，一开始<code>indirect</code>指向<code>head</code>，而<code>*indirect</code>则等于head指针再被evaluate一次，那么就等价于链表的<code>head</code>，很显然此时的<code>*indirect</code>不等于<code>entry</code>，因为entry指向的是第三个节点。于是进入<code>while loop</code>执行<code>indirect = &amp;(*indirect)-&gt;next;</code>，因为<code>*indirect</code>就等价于<code>head</code>，那么<code>&amp;(*indirect)-&gt;next</code>就可以取得<em><code>head</code>的next指针所在的地址</em>，这一行就相当于将<code>head</code>的next指针的地址赋给了<code>indirect</code>，如下图所示。</p>
<p>赋值结束后，我们又回到了判断条件<code>(*indirect) != entry</code>，此时<code>indirect</code>指向<code>head</code>的next指针，那么<code>*indirect</code>就相当于evaluate了<code>head</code>中next指针中所存储的地址，也就是第二个节点的地址。此时再判断，发现<code>(*indirect) == entry</code>依然不成立，继续执行<code>while loop</code>内部的代码。</p>
<pre class="text"><code>       head                      entry -+
        |                           |
    +-------+     +-------+     +-------+     +-------+     +--------+
    | 1 |   |----&gt;| 2 |   |----&gt;| 3 |   |----&gt;| 4 |   |----&gt;| 5 |NULL|
    +-------+     +-------+     +-------+     +-------+     +--------+
          ^
          |
        +---+
        |   |
        +---+
       indirect</code></pre>
<p>同样地，这次<code>indirect = &amp;(*indirect)-&gt;next</code>会将<code>indirect</code>指向下一个节点的next指针，也就是第二个节点的next指针，如下图所示。此时再回到<code>while loop</code>的判断条件<code>(*indirect) != entry</code>，我们发现<code>*indirect</code>就等价于第二个节点的next指针，也就是第三个节点，也就是<code>entry</code>，于是退出<code>while loop</code>。</p>
<pre class="text"><code>       head                      entry -+
        |                           |
    +-------+     +-------+     +-------+     +-------+     +--------+
    | 1 |   |----&gt;| 2 |   |----&gt;| 3 |   |----&gt;| 4 |   |----&gt;| 5 |NULL|
    +-------+     +-------+     +-------+     +-------+     +--------+
                        ^
                        |
                      +---+
                      |   |
                      +---+
                     indirect</code></pre>
<p>最后执行<code>*indirect = entry-&gt;next;</code>，由于<code>indirect</code>指向第二个节点的next指针，所以<code>*indirect</code>则等价于第二个节点的next指针，所以实际上这行代码就是将第二个节点的next指针指向entry的下一个元素，从而完美地将entry从链表中删去。</p>
<pre class="text"><code>                          entry -+
      head                          |
    +-------+     +-------+     +-------+     +-------+     +--------+
    | 1 |   |----&gt;| 2 |   |--   | 3 |   |----&gt;| 4 |   |----&gt;| 5 |NULL|
    +-------+     +-------+  \  +-------+     +-------+     +--------+
                     *indirect \              /
                                +------------+</code></pre>
<p>第一次看到Linus的这种写法时，确实觉得非常惊艳，不过我还是对于这段代码保持一个中立的态度。首先，我们可以通过在头部增加一个dummy node，以这种更易读的方式来完成这项任务；其次，从现实世界的软件工程来看，这样的代码未必是最能提高生产力的代码。不过尽管如此，我还是从这个视频里看到了非常珍贵的东西，那就是对代码的追求以及对固有思维的打破。事实上，很多人会忘记对自己已经学到的代码进行思考，把它们当作理所当然的事。比如只会用学校里教的那种最古板的办法去删除链表中的节点，却不去思考这种方式有没有提升的空间。而这又可以拓展到更大的语境下，那些一两年前你认为是对的事情，现在的你是否有重新思考过它们呢？还是你会理所当然地相信曾经相对幼稚的你得到的结论呢？推特上那个<a href="https://twitter.com/ProfFeynman">Richard Feynman的账号</a>很有意思，其中<a href="https://twitter.com/ProfFeynman/status/1159322163075112960">有一条我很喜欢的推</a>：</p>
<blockquote>
<p>Learn. Unlearn. Relearn.</p>
</blockquote>
<p>Unlearn？听起来会不会有点熟悉，是啊，Master Yoda训练Luke的时候也说提到过这个词。Unlearn很重要，在我看来，第一次的那个Learn，我更愿意称之为模仿，你模仿你的老师，模仿书本上的知识，最后慢慢地入门。而Relearn才是你真正理解某个概念的本质的时候，我觉得这也是最容易出现创新的时候。</p>
<center>
<img alt="you must unlearn what you have learned" height="300" src="../imgs/you-must-unlearn-what-you-have-learned.jpg"/>
</center>
<p>最后，请注意Linus最开始写出这段代码的动机，学校里教的那种方法，多了一个if statement。每个人都应该想想，对于你自己来说，这是“仅仅只是多了一个if statement罢了”，还是“这里居然有一个多余的if statement”呢？</p>
<hr/>
<p>Thanks to the discussion on the Internet:</p>
<ul>
<li><ol type="1">
<li><a href="https://stackoverflow.com/questions/12914917/using-pointers-to-remove-item-from-singly-linked-list">Using pointers to remove item from singly-linked list</a></li>
</ol></li>
<li><ol start="2" type="1">
<li><a href="https://stackoverflow.com/questions/51794426/delete-an-entry-from-a-singly-linked-list/51796733#51796733">delete an entry from a singly-linked list</a></li>
</ol></li>
<li><ol start="3" type="1">
<li><a href="https://news.ycombinator.com/item?id=12793624">Applying the Linus Torvalds “Good Taste” Coding Requirement</a></li>
</ol></li>
</ul>
<p>(The End)</p>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry><entry><title>I quitted PhD</title><published>Mar 06, 2020</published><updated>2020-03-06T11:22:14Z</updated><link href="http://jujuba.me/posts/I-quitted-phd.html"/><id>http://jujuba.me/posts/I-quitted-phd.html</id><author> <name>Jiahao Cai</name> </author><content type="html"><![CDATA[ 

<header id="title-block-header">
<h1 class="title">I quitted PhD</h1>
<p class="date">Mar 06, 2020</p>
</header>
<p><img alt="The quit problem" height="300" src="../imgs/the-quit-problem.gif"/></p>
<!-- <img src="../imgs/this-is-fine-doggy.jpg" alt="This is fine" height="250"/> -->
<p>做出这个决定大约是在2019年的10月中旬， 从加入到退出，我在PhD这个program里呆了一年时间，这一段经历对我而言，其实就是一段祛魅的过程。所有那些我在加入时有过的情绪，热情、激动，甚至是虔诚，慢慢变成了不解、不安、与痛苦，最后一切都烟消云散，我可以内心毫无波澜地审视这一切。PhD在我心里变成了一个再普通不过的东西，我不再觉得PhD这个title值得我用几年的时间去换取，也不再觉得相对于其他我能做的事，读PhD的过程可以带给我更多的收获。</p>
<h2 id="所谓-world-class">所谓 world-class</h2>
<p>不得不说，来了美国之后发现这里确实处处洋溢着世界第一的骄傲，比如说，在美国你可以领教到很多world-class的事，所谓的世界级。投简历的时候你会看到，类似于“Join us to do the world-class product”的描述；学生手册上写着“The PhD program prepares students for faculty careers at world-class universities and for research positions in leading government or industrial research labs”；就连夏村的消防车上都写着，“Charlottesville, a world-class city”。第一次面对如此多world-class的时候，我的心中怎么可能没有任何波澜呢？谁不曾想成为world-class的一份子？但是慢慢地我发现事情并没有那么简单。</p>
<p>回想我当初第一次看到学生手册上写的world-class，心潮澎湃，着了魔一般急切地想要投身于“world-class research”然后“expand the frontiers of knowledge”。那时候的我几乎是虔诚地对待这个词，我觉得world-class曾经是对我来说是触不可及的东西，我为自己朝着world-class迈进而感到无比高兴。这种感觉随着我读论文的数量增加，research的进度增长而慢慢消失，放眼望去，密密麻麻的都是重复性的，无聊的，炒冷饭式的工作。由于巨大的失望，最终彻底走到了这种感觉的对立面，我才知道所谓world-class是如此不堪一击。诚然，我们大部分人都耗费了巨大的精力才走到了这一步，走到了world-class的面前。可是如果此时你看见前方的生活并不是你想要的，你会回头吗？</p>
<p>至于夏村消防车上写的world-class，我只当这是当地人的一种幽默，否则的话，那就只能是一种无知式的自豪了。欧洲的那些默默无闻的宁静小镇们，看到这个world-class，估计只会哑然失笑。</p>
<p>world-class，大概是我来美国受的第一次骗。</p>
<h2 id="phd">PhD</h2>
<p>这一年时间里，我从完全不知道PhD为何物到quit PhD，我的观念发生了很大的变化，比如说PhD这个title在我心里已经失去了价值。我曾经以为每个想读PhD的人都是充满好奇心的，真心实意地想要拓宽人类知识边界的人，但是我发现现实世界里读PhD的一般就两种人，一是不知道自己当下该干嘛的人，于是读个PhD，在学校里继续混着；二是一心想要找教职的人。前者一般天天划水，水平十分低劣；后者往往非常努力，但是目的性也非常之强，他们精确地知道想要找到一份教职需要多少顶会paper，我尊重他们的努力，不过也仅此而已。</p>
<p>为什么说PhD在我心里已经失去了价值，因为我自己在做research的过程中，见到了太多的所谓划水PhD，实在令我感到不适。所以现在的我觉得PhD这个title并不能说明什么，如果一定要说明什么，那就是我知道这个人八成在学校里呆了好几年 :) 读过PhD的人都知道，PhD们之间的差距可以大到令人咂舌，我们只能通过他在PhD期间完成的工作来真正说明这个头衔的含金量。可惜的是，由于这世界上的大部分人都不是PhD，他们不懂得如何分辨一个好的PhD和坏的PhD<a class="footnote" href="#faculty" id="faculty_ref"><sup>*</sup></a>；又由于PhD在这个世界上的稀少程度，人们往往愿意盲目地奉上较好的待遇。单凭PhD的title就能得到良好待遇的事实，吸引了大批只对该title感兴趣的人涌了进来，同时也让一大堆已经了解自己不适合读PhD的学生赖在这个项目里不肯离开，因为他们渴求这个title。很多人就像爱因斯坦曾提到的，他们是“为了纯粹功利的目的而把他们的脑力产物奉献到祭坛上的”<a class="footnote-ref" href="#fn1" id="fnref1"><sup>1</sup></a>。</p>
<p>我不知道是谁第一个把做research叫做搬砖的，但我不得不说这实在是天才般的比喻，PhD们日复一日，为了发paper而重复着微妙的实验。在这过程中，某些搬砖技巧不足，或者搬砖不够努力的人就会被请出这个项目；另一些人则非常努力的搬砖，不过与此同时有些人（比如我）会开始怀疑这一切的意义与动机。每个教授都会说自己是想要拓宽人类知识的边界的，PhD们也都是这么被告知的。一开始我也确实觉得research是关于一心为了拓宽人类知识边界的，后来我发现并不是；于是我退而求其次，只想做个老板眼中的“成功”PhD，但我又发现所谓“成功”PhD的终极意义居然就是找到一个好教职并继续做research，于是我开始问自己我是否真的想成为一个faculty。我想了想觉得没什么兴趣，比起一个做research的faculty，我宁愿去专心教本科生上课，我觉得那会带给我更多快乐。第二个学期的时候，我做了本科生Operating Systems这门课的TA，当时这门课分成了两个section，一个section是我老板上的，另一个section是C上的。一开始我不知道为什么C一个Berkeley来的，PhD期间research搞得风生水起的人，会来这里专心教书。但是渐渐我发现他对于教书的热情真的非常动人，这门OS是直接改的MIT的OS课，降低了一点难度又没有失去精髓；Piazza上有学生提出问题，他总是会及时地出现。有次半夜两点有学生问问题，我正在编辑回答的时候，突然发现怎么有个人在co-editing，仔细一看原来是C；每周开会C都会认真记下TA们的反馈，讨论课程的改进，其中有一个作业是实现ftp服务器，他一直期待大家提出一个更好的protocol让学生去实现，因为他始终觉得ftp设计得太垃圾了。刚才我看了一眼这个学期课程表，发现这学期OS两个section一共有两百多个学生，lecturer却只有他一个，也许是他觉得其他人教得都不如他吧。在我眼里，C的人生比他的大多数同事们都更有意义。</p>
<p>发现自己对faculty没兴趣之后，于是很自然地，我决定退出。说到底，一个“成功”PhD所需要的品质，比如头脑聪明，比如有想法，比如耐得住寂寞，仔细想想，这些品质放在任何行业和领域，都是非常宝贵的品质。对我来说，与其耗费好几年青春换得一个我没兴趣的职位（faculty）的入场券，不如带着这些品质去探索更大的世界。</p>
<p>有人说，PhD的过程是一种筛选，而这种筛选“总是筛掉最差的，但也筛掉最好的”<a class="footnote-ref" href="#fn2" id="fnref2"><sup>2</sup></a>，其实有一定的道理。</p>
<p id="faculty">
<b>*</b>: 从某种意义上来说，这也是由如今research的方式决定的——大部分人都只在一个很小的细分领域内深耕，researcher们互相并不非常清楚彼此的research，而CS这个学科中又恰好充满了各种各样的细分领域。假设一个学校想要招生，很有可能学校根本没有那个细分领域的专家，评估新人的教授只能从侧面来考察这个候选人。不过从侧面考察这件事就很微妙了，说句实话，PhD这么多年读出来，不管自己的工作是不是真正重要，也能将自己的工作吹出花来了，说不定还早就给自己洗脑，相信自己的工作一定无比重要。毕竟如果自己都觉得自己的工作不重要，估计也就不愿意把自己的美好青春放在这些工作上了，早就半路quit了。<a class="footnote-back" href="#faculty_ref">↩</a>
</p>
<h2 id="getting-phd-is-not-a-war">Getting PhD is NOT a war</h2>
<p><img alt="Brain on a stick" height="300" src="../imgs/brain-on-a-stick.gif"/></p>
<p>老板与学生的关系向来都很微妙，尽管学生手册里写的是，“RAs and advisors are colleagues in research and the employer-employee relationship is rarely visible as they work together to expand the frontiers of knowledge”，但是事实并非如此。</p>
<p>读PhD的几乎每一天我都过得很郁闷，因为在我眼里，我的身份更像是一个worker，一个employee，或者一个soldier，这让我感到迷惑且痛苦。而且我无法忍受某些话术，比如</p>
<blockquote>
<p>“我给了你这个project，你就应该尽力去实现它，如果你觉得我错了，那你就指出来，否则就按我说的做”</p>
</blockquote>
<p>这个话术的精髓在于，引入一个看似正确的逻辑（if x then y else z）让学生闭嘴并且去干活，但是却闭口不提这个结果（y）所需要的苛刻的前置条件（x）。有哪个刚入学的PhD可以随随便便地指出老板的错误呢？如果不能指出错误，那么就只剩下了服从，在脑子一片迷茫的情况下服从，是我所不能忍受的事。正确的做法应该是真诚地对待学生，与学生建立良好的平等关系，及时地引导学生并解决学生的疑惑。或许有人会说，“你的要求太高了，怎么可能会有这种老板呢”，我觉得这种人就是典型的自我阉割惯了，把自己的要求降低到了一个不正常的维度，于是看到别人提出的正常的要求就会露出一副吓坏了的神色。</p>
<blockquote>
<p>“如果你能完成按时这个project，你每天睡12个小时我也不在乎，（对于你现在的困境）唯一的办法就是变得more efficient”</p>
</blockquote>
<p>Again，这个话术的精髓也在于忽略达到结果所需要的条件，只提出了看似宽容的每天睡12小时。这样一来，就可以把workload过大的责任消于无形，问题现在出在了你的身上，你牺牲了睡觉的时间娱乐的时间来做这个project，完全是你自己的选择，因为你不够efficient。计划制定者一点错也没有，相反，他很仁慈，在某种实则不可能的条件下，你甚至可以每天睡12个小时<a class="footnote" href="#bitcoin" id="bitcoin_ref"><sup>*</sup></a>。正确的做法应该是为学生制定合理的计划，如果学生实在达不到要求，那么可以直接提出让学生另寻出路；或者招募更有经验的postdoc来充当老板与学生之间的缓冲。给着卖白菜的钱指望学生出卖白粉的力气是不可取的，指望学生长时间地用爱发电也是不现实的，事实上我真的在很长一段时间里尝试用爱发电，结果是我开始失去动力，开始怀疑我是否还喜欢security。</p>
<p>我可以理解Assistant Prof.往往会面临巨大的来自tenure的压力，但是我不愿意有人将这种压力直接（甚至是加倍）传导到我的身上。</p>
<p>其实大学里也有很多可以制衡老板的机构，但是这些机构一般只能在与学术无关的事情上发挥作用。另外，我也并不相信他们真的会站到我的这一边，而且我并不觉得他们能为我做什么，这是我与老板之间的事。</p>
<p>听到有人说读博和婚姻很类似，我觉得是的，老板与我的关系就能说明很多。如同很多婚姻一样，我们也有一个非常良好的开始。我还记得当初我刚来读Master的第一个学期，天天对着课表发愁，觉得没什么感兴趣的课可以上。就在这时候，他正好作为一名新AP加入，并且开了一门新课。那时候我一看他的履历就知道他的方向和我的兴趣应该是完美契合的，我自然马上选了他的课。相似地，我相信他也肯定感觉到了我的兴趣与实力，我记得那才是那个学期的第一节课还是第二节课，他就开始邀请我读PhD，并且在那个学期剩下的时间里时不时地找我吃饭，劝说我读PhD。我虽然一直犹犹豫豫，始终没有答应，但是我知道我的内心肯定还是希望尝试的。我嘴上说着自己要刷题找实习，但是我花在research上的时间，至少十倍于刷题找实习的时间。那个学期之后，我还是转到了PhD，我以为这是一段佳话的开始，我以为我们会像一个前途无量的startup一样，破土而出，在这个学术界里占据一个角落，留下我们的名字。可惜事与愿违，尽管老板与我之间并没有想象中的剑拔弩张，只是日子一天天过去，我们都慢慢明白彼此不合适。说不可惜是不可能的，我们在技术上互相赏识，当初是他亲手写的推荐信，在春季不招生的情况下让我破格转到PhD，我也一直把他当作榜样。只不过我是一个缺乏安全感的人，他对我的各种要求使我感到烦躁并且失望，而且我们之间也太缺少深入的，与学术无关的谈话了。在这种情况下，我陷入了深深的焦虑，我知道再这样下去我只会变成一台不属于我自己的机器，当我quit之后，我才终于又感觉到，我的命运又被我牢牢地抓在手里了。</p>
<p><strong>说到我与老板之间的相处，让我给你们举一个例子吧。</strong>我刚转到PhD的时候，是春季学期，那时候他对我说，如果我们能在暑假结束之前发出两篇顶会文章，那你就可以做到“above average”了。我当时并不知道两篇顶会意味着什么——直到后来我才知道在system领域，有很多PhD花了三年甚至更久才能发出第一篇顶会；直到后来我才发现，隔壁某大牛组的PhD，花了六年拿着两篇顶会文章就毕业了。但是在那个时间点，我选择无条件地相信了他，我只知道在这个时间之内完成两篇顶会，一定是一个很棒的成就。如果你对CS System这个领域有所了解，那你应该已经能猜到我接下来的大部分故事了。在接下来的日子里，我非常努力地工作，也没有时间去看别的PhD在干嘛，当然也就不知道老板给我定下的“above average”的实际难度究竟是多少，我只知道我感觉越来越难。我开始对自己非常失望，我满脑子都是“暑假结束前两篇顶会 = above average”，可是直到第一学期结束前，我还没有完成我的第一篇文章，那我得有多糟糕？而且更让我感到恐惧的是，我对发论文一无所知，我并不知道发一篇顶会需要多少步骤，我也并没有被告知下一步是什么，我只被告知我应该尽快完成我手上的任务。所以我很焦虑，对未来的未知以及无法掌控加剧了我的焦虑，我每天都在挫败感中度过。但是老板不一样，他从一开始就知道我做不到，实际上，就连他自己也做不到。他只是想通过这种方式来push我，让我尽可能多地搬砖罢了。我当然也希望尽可能多地搬砖，可是以这种方式来push我，利用我的恐惧与焦虑，我实在是不能接受，也不觉得这是一种decent的方式。事实上，按照我的性格，从他开始这么做的第一天起，我们的分离就只是时间问题了。暑假结束之后，我投出了我的第一篇文章，也许我已经超过了95%或者更多的PhD，但是那又怎么样呢？长久以来，我都背负着巨大的压力，我的一口气都是被那篇paper吊着，我以为投出去之后一切就会变好，可惜我并没有那种感觉。我只觉得空虚，觉得没有意义，觉得自己应该重新规划自己的人生了。那个时候，我对老板的做事方式耿耿于怀，而如今，quit后的我也已经理解了，我又能改变什么呢？他是真心实意地想要帮助我，希望我成功，也是100%地相信，用那种方式push一个人是对的，是有用的。也许是因为他的成长环境吧，他也对我说过一些他以前的事情。我为他感到难过，也为能理解他的我感到难过。我想把那个令我难过的东西称之为”亚洲人的悲哀“，或者更广义一点，”内卷后遗症“。</p>
<p id="bitcoin">
<b>*</b>: 这样的话术在生活中其实十分常见，它们往往重点渲染结果，而对苛刻的条件一带而过。比如，前几天一个朋友对我说，“比特币现在没有那么有用，但是如果公链做的很牛逼，那这个代币就值钱了”，这句话本身也许是对的，但是这并不代表你应该投资比特币。<a class="footnote-back" href="#bitcoin_ref">↩</a>
</p>
<h2 id="学术界的信息不对称问题">学术界的信息不对称问题</h2>
<p>上面说到了我的那种失控的焦虑以及命运不掌握在自己手中的感觉，这里我可以详细解释一下。在此之前，我想起两个看似无关的事：</p>
<ol type="1">
<li>某天我跟同学在交流找工作的经验，我分享了很多有用的信息，同学感叹说，收集信息对于找工作来说真的好重要，<br/>
</li>
<li>我在要转入PhD之前去找我的本科老师交流，她对此表达了一丝担忧，意思是如果我真的想读，让我还是去申请更好学校的PhD，找功成名就的教授。</li>
</ol>
<p>收集信息的能力很重要，两个人想做同一件事，拥有更多信息的人有更大的成功机会，因为这些信息可以帮助这个人制定计划，评估风险，从而更好地把握整体走向。我的信息收集能力让我在大多数时候都掌握主动，并且信心十足，但是当我读PhD之后，事情产生了变化。首先，PhD应当探索人类知识的边界，由于当今学术的特性，每个人往往都只能专注于一小块领域，这块领域的资源是极其有限的，这个领域的论文就这么多，大家都读着同样的论文，似乎并没有什么信息优势可以获取。每个人都是平等的矿工，对着面前的各种难题一铲一铲地挖，期待着下面的金矿。可是事实果真如此吗？其实学术界也有信息优势，而它们存在于那些最顶尖的lab里，那些lab掌握了最前沿的信息，也引领了学术界的动向。而那些信息并不像我曾经获取过的信息一样，只要Google上查一会就能获得，相反，作为一个outsider，我接触不到那些信息，而那些信息几乎可以决定你在学术界的成就。这让我感到不安且烦躁，我觉得我的人生被莫名其妙地设置了一个天花板，我觉得我的命运不再掌握在我自己的手里。或许你听说过“老板的水平决定了你的上限”之类的说法，这就是了。</p>
<p>当然你会想，为什么要去蹭所谓的信息优势而不直面未知呢？那不是PhD的意义所在吗？说不定那些信息反而会限制你的思路，一个产生伟大研究的灵感就从你手上溜走了。头铁的我当然这么想过，但是老板是否会让你直面未知？特别是Assistant Prof.，要知道tenure的压力是很大的，AP决不会同意你冒着发不出论文的风险憋一个大招。就算你有了那种研究的自由，你是否思考过直面未知的赢面又有多少<a class="footnote" href="#freedom" id="freedom_ref"><sup>*</sup></a>？产生伟大研究的几率如此之低，而成本却是如此之高，与其沉浸在自己大多数时候都只能庸庸碌碌地做研究的痛苦之中，不如去寻找其他的方向。这让我想到Witten说过的一句话：“我们其实不需要100个弦论学者，只需要一两个就行了；但我们还是需要招100个研究弦论的学生，因为我们不知道他们之中哪一两个人能成为我们需要的弦论学者”。说实话，我不知道我是不是那百分之一（尽管我觉得我比我身边大部分人都强得多），可是我知道我百分之百可以成为一个很好的工程师，于是我的选择就渐渐清晰了。当然你可以鄙视地说，我看见了一笔不划算的投资，于是知难而退，which is very true. 说到底，人生太过短暂，我只想选择更能够实现自我价值的路。</p>
<p id="freedom">
<b>*</b>: 其实作为一个PhD学生谈研究的自由是一件很搞笑的事，就像太监讨论性生活一样没有意义，因为本质上学生是为老板打工的（<em>为什么大家把导师叫做老板？</em>）。至于赢面问题，有兴趣的人可以看下<a href="http://www.pgbovine.net/PhD-memoir/pguo-PhD-grind.pdf">The PhD grind</a>，里面讲到了Klee-UC在Stanford诞生的故事，一个来自顶尖学校，功成名就的Full Prof.，想要学生<em>实现</em>他的一个想法，花了整整五年。代价是什么呢？在这五年里有四个学生尝试过这个project，只有一个学生成功了，剩下的两个直接像我一样quit PhD了，还有一个（作者自己）去寻找别的项目了。<br/>
&gt; In the end, it took three attempts by four Ph.D. students over the course of five years before Dawson’s initial Klee-UC idea turned into a published paper. Of those four students, only one “survived” —— I quit the Klee project, and two others quit the Ph.D. program altogether. From an individual student’s perspective, the odds of success were low.<a class="footnote-back" href="#freedom_ref">↩</a>
</p>
<!-- ## “少年天才”们

之前提到我很崇拜老板的技术，
早在本科时期我就遇到过很多自称从很小的时候就开始学习编程的人，到了美国之后就更加了，各种“少年天才”满地走。我老板就是其中一位。。。
我有一次遇到了我的TA。。。那天晚上，我非常崩溃，我认为我再也超不过这样一个人了，但是仅在一天之后，我又改变了想法。
那些所谓的“少年天才”早早地超到了我们的前面，但是我们真的没有希望超过他们了吗？并不是的，边际效应xxxxx
如果上面的例子还没有说服你，那么就想想龟兔赛跑的例子吧，你觉得一开始落后的乌龟最后获得了胜利只是个美好的童话吗？更何况，你有没有想过，也许当前落后的你，才是那只兔子呢 :)
 -->
<!-- 
## 打倒心中的权威

自从大家有了专业以来， -->
<h2 id="没人值得你学习四五六年">没人值得你学习四/五/六年</h2>
<p>四/五/六年是一段漫长的时间，也是很多PhD毕业所需要的时间，在这么长的时间里，到底该学些什么？下面是我的看法：<br/>
我们都很了解“授人以鱼，不如授人以渔”的道理，换个角度思考，如果要学习，到底该学鱼，还是渔呢？我想大家都知道要选择渔，那么渔在这个context下代表什么？在我眼里就代表处理各种事的方法，包括生活，包括research。学习这些方法，我认为并不需要花费太久的时间，而且重要的是，随着时间的推移，学习方法的收益将会急剧降低，因为你已经见过老板处理大多数事情的方法。举个例子，你用了一年的时间观察了老板90%的方法，那么剩下的五年你就只能观察剩下的10%了。剩下的一些方法，就像程序中的rare branch一样隐藏得很深，需要特定的事件来trigger之后，你才能看到老板是如何处理的，但是这些方法真的值得你花上很多年去学习吗？如果你觉得方法的精要藏在那些你尚未发现的方法里，那你大概率是错了，因为真正重要的，需要学习的方法，就藏在每天的生活里，每天的research里。或许你会说，“那老板还是比我强啊，我还是可以从他身上学到很多东西”，可是你确定你学到的是渔而不是鱼吗？考虑以下情况，我们假设<code>鱼 = 渔的efficiency * 时间</code>，你有没有想过，当你到了老板现在的年龄的时候，你也许会比他拥有更多的鱼？其实结果并不重要，重要的是你有没有从这个角度思考过，也许很多人从来就没有想过，假以时日，你完全可以超过自己的老师们。我离开本科的时候，自信自己在写代码方面已经超过了我们学校的绝大多数老师，除了两个比较年轻的老师，不过我觉得，这没什么了不起的，两三年之后我就可以超过他们。</p>
<p>也许有人会说“没人值得你学习六年”太夸张，然后搬出爱因斯坦/费曼/普朗克云云，说自己愿意终身跟随这些大师学习。其实这又是把鱼和渔给混淆了，如果我与爱因斯坦共事，也许我六个月就会离开他了，一个月观察他的方法，剩下的五个月在纠结要不要离开他，毕竟我在离开一颗超级聪明的大脑 :) 渔，也就是做事的方法，是很因人而异的东西，有些方法需要你废寝忘食，比如每天两点睡五点起；有些方法则需要你智商180才能使用。有些人只看到了对方有一大堆鱼觉得对方身上一定有可学习的东西，其实是不对的。如果你看到这个方法对你而言毫无实践性，我看不到继续学习这个方法的意义。每个人都是独特的，没必要去想着做第二个爱因斯坦/费曼/普朗克，从各个人身上寻找可学习的长处，融合成为自己的方法，这才是最重要的。至于鱼的数量，当方法正确时，你需要的只是时间。当然，这种思考方式只适合像我一样希望修炼自己的钓鱼方式，然后钓到属于自己的鱼的人。向比自己厉害的人学习，从他们身上拿到鱼固然也可以给自己带来很好的结果，可是这却不是我所喜欢的方式。</p>
<p>所以呢，如果你想学习一个人做事的方法，根据对方水平不同，学习几个月到一年的时间即可。至于PhD为什么需要这么长时间，那是另一个复杂的问题。写到这里我突然想到一件事，在我转到PhD之前，我去找我们学院的一个快退休老教授，他问我为什么要读PhD，他说每个人读PhD都有他的原因，他当时读PhD因为他只想当个大学教授，而读PhD是通向大学教授的唯一路径。我时常想起这件事，并且感叹于他的坦诚。</p>
<h2 id="不再年轻">不再年轻</h2>
<p>或许有的人会说，从上面的字里行间可以看出，这些问题出现的主因在于我的水平不够，对于这种评价，我可以很肯定地告诉你，你错了，我可以很自信地告诉你，我就是我们学院最强的学生之一。我离开的原因之一单纯就是觉得我读得很不爽，不仅如此，我还呼吁所有PhD读的不爽的人都马上quit，去其他地方实现自己的价值。读PhD这事有时就好像996的怪圈，理论上只要大家都抵制996，拒绝为996的公司工作，那么996的现象就会消失，但是事实却是总有那么一帮没有骨气的人像舔狗一般地为公司工作着，永远以为自己和资本家穿同一条裤子。读PhD其实也一样，如果每个PhD都读得不爽就退学，那么老板还有可能会压榨学生吗？现实世界里有很多老板可以肆无忌惮地压榨学生，因为他们知道，无论如何，总会有不明真相或者执迷不悟的学生前赴后继地加入的。消除老板与学生间不平等的关系就像是一个美好愿望，它永远也不会实现。</p>
<p>想到这里，我突然觉得我不再年轻了，因为我开始希望别人能够听进去我的劝告，所谓过来人的经验。我在生活中，网络上，都观察到一些人，看到了有人从某老板门下quit，却仍前赴后继地想要加入。原因很简单，他们觉得别人离开都是因为能力不足，觉得自己都是特殊的那一个，觉得自己一定能抗下所有的事。我也曾经是这样的一个人，我就觉得自己就是那个最独特的人，不管所谓过来人如何描述某件事的难度，我也会觉得我自己一定可以的，他们将这件事描述得越难，我只觉得越兴奋，越想做成这件事。就好像我在第一学期的时候想要找实习，有个关系很好的朋友帮我联系了个面试。面试之前我在地里搜了一圈，确定了可能的面试题，但是我却一道都没有做。尽管我看过无数人说面试要刷题，但是我始终觉得我不需要，我觉得真正的面试就应该面对一道从未见过的题，然后在规定时间内解决它，那才刺激，那才是能力的体现。那是我的第一次面试，我面得很糟糕，毫无意外地挂了。那是一次很惨的面试，我第一次知道，尽管我自认为我的编程水平不知道高到哪里去了，可是我在毫无准备，毫无练习的情况下会表现得如此惊慌失措。面试官人很好，最后五分钟一直在安慰我，而我则因为意识到自己并不是那个特殊的人而在最后五分钟里一直努力忍住想哭的欲望。</p>
<p>是的，如果我一直坚持下去，我一定能完成这个PhD，我确实会完成了一个比较难的成就，可是那又怎么样呢？我得到的是我想要的吗？而我失去的又是我在乎的吗？我不再会纯粹为了挑战某件事而去完成它了，其实退一步看，摆在我面前的难题可以有很多，升职，创业，以及很多我还不知道的路。我没有时间再去想将他们全部完成了，我只想找到一条最能实现自我价值的路。</p>
<!-- 如今，我已经不会再这么想了，我从那个被劝说的人变成了劝说别人的人。我开始重视所谓过来人的意见，因为我知道再也没有那么多时间可以去浪费去试错，我只想找到一条最能实现自我价值的路。 -->
<h2 id="他人的看法与对自己的评价">他人的看法与对自己的评价</h2>
<p>我见过很多人对他人的评价耿耿于怀，非常在意别人如何看待自己，对不公正的批评感到难过，气愤，甚至痛苦，我觉得大可不必。我的观点是，这个世界上的每个人，只有自己才有资格公正地，合理地对自己作出评价，原因很简单：只有自己才能完整地看到全部的自己，而其他所有人都只能看到我生命中的一部分。换句话说，所有他人的评价都是片面的，带有偏见的，不完整的，我应该使用挑剔的眼光来看每一个来自他人的评价。我也曾经因他人的评价而痛苦，可是后来我才发现，随意在意他人的评价是很危险的，随意给予他人评价我的权力无异于递了一把可以伤害自己的尖刀给对方。后来我意识到，很多人其实根本没有评价我的权力。</p>
<p>然而，把评价自己的权力牢牢抓在自己手上是危险的，“With great power comes great responsibility”。想象一下，如果全世界只有你自己可以评价你自己，那么你的评价会左右你对自己在这个世界中的定位，如果定位错误，那就有可能陷入巨大的困境。我的应对方式很简单，我非常非常虔诚地对待这种权力，时刻思考反省，自己对自己的评价是否公正，是否有失偏颇。一味地看高或者看低自己，都是我所不希望发生的。</p>
<!-- 把评价自己的权力牢牢抓在自己手上又是美好的。我一直对K感到很不服气，于是 -->
<p>说回PhD的事，几乎每个PhD candidate都会收到来自老板的大量评价，很多人天真地将老板的每个评价认真对待，却殊不知这些评价往往都是带有某种目的性的。大部分所谓的老板-学生关系，其实就是employer和employee的关系罢了，想想现实世界里下雇主和员工的关系，你还会像以前那样天真吗？很多老板会给一大堆负面评价，损害你的自尊，伤害你的感情，贬低你的能力，很有可能这些都只是为了让你更听话地卖力工作罢了，“你已经如此糟糕了，再不听从我的建议，你还有未来吗？”。在我quit之后，我意识到，这种东西其实跟某种所谓精神控制的把戏有很多共通之处 :)</p>
<!-- 把评价自己的权力牢牢抓在自己手上可以带来一些有意思的事。我是个喜欢比较又不喜欢认输的人，在我quit之后，我就在心里设定了一个比赛，我觉得我以后会超过K，而且会in a easier way，不像他一样那么工作狂。但是如何比较呢？比paper吗？我们的人生已经分叉了，我大概率不会再去学术界了。那比什么呢？其实我也不知道， -->
<p>在这里必须要说明的是，我在上面写的都是关于“人”的评价，除此之外，还有对“事”的评价。比如你做了某件事，然后你的队友/上级对你做的这件事做出了一个评价，这就叫做对“事”的评价。这些评价往往是需要听取的，大多数时候它们都能帮助你进步。可惜的是，现实世界往往是复杂的，只有很少的人可以清晰地分开对“人”的评价与对“事”的评价，人们有意无意地将两种评价混在一起，以达到某种目的。所以，当你看到一个评价时，请擦亮眼睛，别让无谓的评价伤害了你。</p>
<h2 id="把水放干">把水放干</h2>
<p>我在yinwang的文章里看到过一个很有趣的例子<a class="footnote-ref" href="#fn3" id="fnref3"><sup>3</sup></a>，讲的是在Cornell求学的生活：</p>
<blockquote>
<p>有人打了个比方，说Cornell说要教你游泳，就把你推到水池里，任你自己扑腾。当你就要扑腾上岸时，他在你头上用榔头一砸，然后继续等你上岸。当你再次快要扑腾上岸时，他又举起一块大石头扔到你头上，这样你就可以死了，可是Cornell仍然等着你游上岸… 这就是对我在Cornell的经历的非常确切的比喻。<br/>
…<br/>
现在我觉得自己就像那个到Cornell学“游泳精髓”人，本来就是会游泳的，可是每到岸边Cornell就搬起大石头来砸我，还说我不会游。于是我钻到水底下钻了一个洞，把水放干。</p>
</blockquote>
<p>我也是一个渴望学到所谓“游泳精髓”的人，可我却发现在这一年里，我非但没有学到“游泳精髓”，反而天天被人说不会游泳，搞得很不开心。大多数时候，当我游到岸边时，我只会被一锤子砸晕然后被命令重新来过。可是，我不觉得我是一个不会游泳的人，相反，我很自信我可以游得很好，我不想屈服于这些奇奇怪怪的约束，我很清楚这不是我想要生活，于是我也在泳池底下开了个口，把水放干，然后离开。</p>
<h2 id="正式quit-加入google">正式quit &amp; 加入Google（？）</h2>
<p><img alt="Quit PhD to industry" height="300" src="../imgs/quit-phd-to-industry.gif"/></p>
<p>决定跟老板分开的时候，学期还剩下两个月结束，学院里的老教授建议我在剩下的时间里找别的老师谈谈，找一个合得来的老师重新开始。我很感谢他真诚的建议，但是我从来没有找过别的老师，因为我早就发现我对其他教授的工作都不感兴趣。部分原因大概就是，我发现department里的所有老师，除了我的老板以外，都在做Machine Learning相关的工作————无论他之前究竟是做什么方向的工作。至于原因，自然是兴趣，只是我分不清是对Machine Learning的兴趣，还是对funding的兴趣。</p>
<p>我花了两三天决定了接下来要干什么：找工作。很遗憾，我quit的时候是十月中旬，那时候已经是秋招的尾声了。我打开Google的招聘页面，发现校招都关了，我意兴阑珊地准备直接放弃，可是我的一个好朋友强烈建议我投一下社招。没想到的是，第二天Google的recruiter就找到我说要谈一下，因为当时很晚了，他还很贴心地帮我跳过了之前的面试直接让我去onsite。由于跳过了之前的面试，所以我只有十几天的准备时间，本来也没抱太大的希望，只想去湾区玩一圈，没想到去了之后居然一下把所有面试题都解决了。后来就是通知过了hiring committee然后有了口头offer。为什么没有收到正式offer呢？因为我投的是社招，Google的社招必须要先进行一个team match的阶段才会发offer，这个match一般在入职前的一两个月才会进行，而我则一直要到夏天才能毕业。一开始我也很焦虑，不停地催recruiter，但是这件事也超出他的掌控范围了，他也只能对我说，“你100%会得到offer的”，或者是“你110%会得到offer的”。现在也算是佛系了，反正想去就得等，先干点别的吧。</p>
<p>无论最后的结果如何，我都非常感谢Google带给我的美好体验，第一次去湾区，第一次去onsite，第一次在白板上写代码，更重要的是我终于又清晰地知道，我依然是那个编程很厉害的我 :)<br/>
其实这里还有一个插曲，2019年Google只招很少的new grad，很多在我之前面试并且通过面试的人，也没能拿到offer，因为招满了。可是因为我投的是社招，所以并不受缩招的影响。我觉得自己很幸运，有时候我在想，也许这就是冥冥之中的宿命吧。</p>
<p>再后来，到了该正式quit的时候，我拿着表格去找老板签字，快三个月没见了，去之前我还很好奇他会不会问我接下来要去哪。最后他还是问了，我说我应该要去Google了，我以为我说出这句话的时候会很爽，但是其实并没有，他很平静，我也很平静，就像某个学生来找一个素未谋面的教授签字一样。我从来不喜欢主动提出要走，就算签字已经签完了，我还是像以前一样坐在他面前，又像以前一样尴尬又沉默地过了三秒。最后还是像以前一样，“OK”，我先说，“OK”，他也说。我站起来准备走，他送我到门口，我想说点什么临别的话语，却脑子一片空白。我发现我还是像从前大多数的时候一样，来到这个办公室之前，总是没有准备好所有自己要说的话。只不过这一次，他不会再因为这个而感到不满了。慌乱之中，我留下一句“I may come back later to visit”，就这样吧。</p>
<h2 id="写在最后">写在最后</h2>
<p>我依然很尊敬我的老板，但是我们也真的不合适，他自己承认不知道怎么教我，不知道怎么跟我沟通，还说自己喜欢debug，但是却找不到改变我的方法，找不到问题出在哪里，当时我坐在他面前，没有说出口的话是，也许问题并不只出现在我身上…确实，后来招进来的学生也遇到了和我一模一样的问题，或许更严重，我尽我所能地帮助他们，也告诉他们这一切都曾经也在我身上发生过。或许等时间慢慢过去，两个人都会改变，慢慢适应彼此。但是我和他都太知道我们自己想要什么了，我们都深信自己的路是对的，我们不愿意妥协，也不可能改变自己而成全对方。无论如何，对于我们俩而言，与其呆在一起相互消耗，分开确实是最优的结果。特别是当他知道我很好，而我也知道他很好时，我们不自觉地就将对彼此的期望拔高到一个很高很高的地方，没有达到那种期望所带来的失望，是会把人搞疯的。所以，没有必要再继续了，希望我们一切都好，未来的某一天，我们的生命也许依然可以有所交集。</p>
<p>一年前，我将自己的部分经历po在网上，有一些人通过那篇文章找到我，有希望得到我的帮助的，也有单纯钦佩我的勇气与洒脱的。我很开心那篇文章产生了很多正面的影响，并且希望这篇也可以帮助到一些人。</p>
<p>(The End)</p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><p><a href="https://bbs.pku.edu.cn/v2/post-read.php?bid=12&amp;threadid=265">探索的动机</a><a class="footnote-back" href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://www.yinwang.org/blog-cn/2014/01/04/authority">常青藤联盟和“世界一流大学” - 我和权威的故事</a><a class="footnote-back" href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://www.yinwang.org/blog-cn/2014/01/04/authority">图灵奖 - 我和权威的故事</a><a class="footnote-back" href="#fnref3">↩</a></p></li>
</ol>
</section>
<a href="../" style="color:black;font-size:2em;float:right;margin-right:30px;margin-bottom:40px;">[Return to the homepage]</a>
<script>
var code_blocks = document.querySelectorAll("pre.sourceCode");
code_blocks.forEach(function(block) {
  block.classList.add("numberSource");
  block.classList.add("numberLines");
});
</script>


 ]]></content></entry></feed>